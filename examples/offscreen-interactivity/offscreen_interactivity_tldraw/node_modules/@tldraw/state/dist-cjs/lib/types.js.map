{
  "version": 3,
  "sources": ["../../src/lib/types.ts"],
  "sourcesContent": ["import { ArraySet } from './ArraySet'\n\n/** @public */\nexport const RESET_VALUE: unique symbol = Symbol.for('com.tldraw.state/RESET_VALUE')\n\n/** @public */\nexport type RESET_VALUE = typeof RESET_VALUE\n\n/**\n * A Signal is a reactive value container. The value may change over time, and it may keep track of the diffs between sequential values.\n *\n * There are two types of signal:\n *\n * - Atomic signals, created using [[atom]]. These are mutable references to values that can be changed using [[Atom.set]].\n * - Computed signals, created using [[computed]]. These are values that are computed from other signals. They are recomputed lazily if their dependencies change.\n *\n * @public\n */\nexport interface Signal<Value, Diff = unknown> {\n\t/**\n\t * The name of the signal. This is used at runtime for debugging and perf profiling only. It does not need to be globally unique.\n\t */\n\tname: string\n\t/**\n\t * The current value of the signal. This is a reactive value, and will update when the signal changes.\n\t * Any computed signal that depends on this signal will be lazily recomputed if this signal changes.\n\t * Any effect that depends on this signal will be rescheduled if this signal changes.\n\t */\n\tget(): Value\n\n\t/**\n\t * The epoch when this signal's value last changed. Note tha this is not the same as when the value was last computed.\n\t * A signal may recopmute it's value without changing it.\n\t */\n\tlastChangedEpoch: number\n\t/**\n\t * Returns the sequence of diffs between the the value at the given epoch and the current value.\n\t * Returns the [[RESET_VALUE]] constant if there is not enough information to compute the diff sequence.\n\t * @param epoch - The epoch to get diffs since.\n\t */\n\tgetDiffSince(epoch: number): RESET_VALUE | Diff[]\n\t/**\n\t * Returns the current value of the signal without capturing it as a dependency.\n\t * Use this if you need to retrieve the signal's value in a hot loop where the performance overhead of dependency tracking is too high.\n\t */\n\t__unsafe__getWithoutCapture(ignoreErrors?: boolean): Value\n\t/** @internal */\n\tchildren: ArraySet<Child>\n}\n\n/** @internal */\nexport interface Child {\n\tlastTraversedEpoch: number\n\treadonly parentSet: ArraySet<Signal<any, any>>\n\treadonly parents: Signal<any, any>[]\n\treadonly parentEpochs: number[]\n\tisActivelyListening: boolean\n}\n\n/**\n * Computes the diff between the previous and current value.\n *\n * If the diff cannot be computed for whatever reason, it should return [[RESET_VALUE]].\n *\n * @public\n */\nexport type ComputeDiff<Value, Diff> = (\n\tpreviousValue: Value,\n\tcurrentValue: Value,\n\tlastComputedEpoch: number,\n\tcurrentEpoch: number\n) => Diff | RESET_VALUE\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAGO,MAAM,cAA6B,OAAO,IAAI,8BAA8B;",
  "names": []
}
