{
  "version": 3,
  "sources": ["../../../src/lib/primitives/utils.ts"],
  "sourcesContent": ["import { Vec, VecLike } from './Vec'\n\n/** @public */\nexport function precise(A: VecLike) {\n\treturn `${toDomPrecision(A.x)},${toDomPrecision(A.y)} `\n}\n\n/** @public */\nexport function average(A: VecLike, B: VecLike) {\n\treturn `${toDomPrecision((A.x + B.x) / 2)},${toDomPrecision((A.y + B.y) / 2)} `\n}\n\n/** @public */\nexport const PI = Math.PI\n/** @public */\nexport const HALF_PI = PI / 2\n/** @public */\nexport const PI2 = PI * 2\n/** @public */\nexport const SIN = Math.sin\n\n/**\n * Clamp a value into a range.\n *\n * @example\n *\n * ```ts\n * const A = clamp(0, 1) // 1\n * ```\n *\n * @param n - The number to clamp.\n * @param min - The minimum value.\n * @public\n */\nexport function clamp(n: number, min: number): number\n/**\n * Clamp a value into a range.\n *\n * @example\n *\n * ```ts\n * const A = clamp(0, 1, 10) // 1\n * const B = clamp(11, 1, 10) // 10\n * const C = clamp(5, 1, 10) // 5\n * ```\n *\n * @param n - The number to clamp.\n * @param min - The minimum value.\n * @param max - The maximum value.\n * @public\n */\nexport function clamp(n: number, min: number, max: number): number\nexport function clamp(n: number, min: number, max?: number): number {\n\treturn Math.max(min, typeof max !== 'undefined' ? Math.min(n, max) : n)\n}\n\n/**\n * Get a number to a precision.\n *\n * @param n - The number.\n * @param precision - The precision.\n * @public\n */\nexport function toPrecision(n: number, precision = 10000000000) {\n\tif (!n) return 0\n\treturn Math.round(n * precision) / precision\n}\n\n/**\n * Whether two numbers numbers a and b are approximately equal.\n *\n * @param a - The first point.\n * @param b - The second point.\n * @public\n */\nexport function approximately(a: number, b: number, precision = 0.000001) {\n\treturn Math.abs(a - b) <= precision\n}\n\n/**\n * Find the approximate perimeter of an ellipse.\n *\n * @param rx - The ellipse's x radius.\n * @param ry - The ellipse's y radius.\n * @public\n */\nexport function perimeterOfEllipse(rx: number, ry: number): number {\n\tconst h = Math.pow(rx - ry, 2) / Math.pow(rx + ry, 2)\n\treturn PI * (rx + ry) * (1 + (3 * h) / (10 + Math.sqrt(4 - 3 * h)))\n}\n\n/**\n * @param a - Any angle in radians\n * @returns A number between 0 and 2 * PI\n * @public\n */\nexport function canonicalizeRotation(a: number) {\n\ta = a % PI2\n\tif (a < 0) {\n\t\ta = a + PI2\n\t} else if (a === 0) {\n\t\t// prevent negative zero\n\t\ta = 0\n\t}\n\treturn a\n}\n\n/**\n * Get the clockwise angle distance between two angles.\n *\n * @param a0 - The first angle.\n * @param a1 - The second angle.\n * @public\n */\nexport function clockwiseAngleDist(a0: number, a1: number): number {\n\ta0 = canonicalizeRotation(a0)\n\ta1 = canonicalizeRotation(a1)\n\tif (a0 > a1) {\n\t\ta1 += PI2\n\t}\n\treturn a1 - a0\n}\n\n/**\n * Get the counter-clockwise angle distance between two angles.\n *\n * @param a0 - The first angle.\n * @param a1 - The second angle.\n * @public\n */\nexport function counterClockwiseAngleDist(a0: number, a1: number): number {\n\treturn PI2 - clockwiseAngleDist(a0, a1)\n}\n\n/**\n * Get the short angle distance between two angles.\n *\n * @param a0 - The first angle.\n * @param a1 - The second angle.\n * @public\n */\nexport function shortAngleDist(a0: number, a1: number): number {\n\tconst da = (a1 - a0) % PI2\n\treturn ((2 * da) % PI2) - da\n}\n\n/**\n * Clamp radians within 0 and 2PI\n *\n * @param r - The radian value.\n * @public\n */\nexport function clampRadians(r: number): number {\n\treturn (PI2 + r) % PI2\n}\n\n/**\n * Clamp rotation to even segments.\n *\n * @param r - The rotation in radians.\n * @param segments - The number of segments.\n * @public\n */\nexport function snapAngle(r: number, segments: number): number {\n\tconst seg = PI2 / segments\n\tlet ang = (Math.floor((clampRadians(r) + seg / 2) / seg) * seg) % PI2\n\tif (ang < PI) ang += PI2\n\tif (ang > PI) ang -= PI2\n\treturn ang\n}\n\n/**\n * Checks whether two angles are approximately at right-angles or parallel to each other\n *\n * @param a - Angle a (radians)\n * @param b - Angle b (radians)\n * @returns True iff the angles are approximately at right-angles or parallel to each other\n * @public\n */\nexport function areAnglesCompatible(a: number, b: number) {\n\treturn a === b || approximately((a % (Math.PI / 2)) - (b % (Math.PI / 2)), 0)\n}\n\n/**\n * Convert degrees to radians.\n *\n * @param d - The degree in degrees.\n * @public\n */\nexport function degreesToRadians(d: number): number {\n\treturn (d * PI) / 180\n}\n\n/**\n * Convert radians to degrees.\n *\n * @param r - The degree in radians.\n * @public\n */\nexport function radiansToDegrees(r: number): number {\n\treturn (r * 180) / PI\n}\n\n/**\n * Get a point on the perimeter of a circle.\n *\n * @param center - The center of the circle.\n * @param r - The radius of the circle.\n * @param a - The angle in radians.\n * @public\n */\nexport function getPointOnCircle(center: VecLike, r: number, a: number) {\n\treturn new Vec(center.x, center.y).add(Vec.FromAngle(a, r))\n}\n\n/** @public */\nexport function getPolygonVertices(width: number, height: number, sides: number) {\n\tconst cx = width / 2\n\tconst cy = height / 2\n\tconst pointsOnPerimeter: Vec[] = []\n\n\tlet minX = Infinity\n\tlet maxX = -Infinity\n\tlet minY = Infinity\n\tlet maxY = -Infinity\n\tfor (let i = 0; i < sides; i++) {\n\t\tconst step = PI2 / sides\n\t\tconst t = -HALF_PI + i * step\n\t\tconst x = cx + cx * Math.cos(t)\n\t\tconst y = cy + cy * Math.sin(t)\n\t\tif (x < minX) minX = x\n\t\tif (y < minY) minY = y\n\t\tif (x > maxX) maxX = x\n\t\tif (y > maxY) maxY = y\n\t\tpointsOnPerimeter.push(new Vec(x, y))\n\t}\n\n\t// Bounds of calculated points\n\tconst w = maxX - minX\n\tconst h = maxY - minY\n\n\t// Difference between input bounds and calculated bounds\n\tconst dx = width - w\n\tconst dy = height - h\n\n\t// If there's a difference, scale the points to the input bounds\n\tif (dx !== 0 || dy !== 0) {\n\t\tfor (let i = 0; i < pointsOnPerimeter.length; i++) {\n\t\t\tconst pt = pointsOnPerimeter[i]\n\t\t\tpt.x = ((pt.x - minX) / w) * width\n\t\t\tpt.y = ((pt.y - minY) / h) * height\n\t\t}\n\t}\n\n\treturn pointsOnPerimeter\n}\n\n/**\n * @param a0 - The start point in the A range\n * @param a1 - The end point in the A range\n * @param b0 - The start point in the B range\n * @param b1 - The end point in the B range\n * @returns True if the ranges overlap\n * @public\n */\nexport function rangesOverlap(a0: number, a1: number, b0: number, b1: number): boolean {\n\treturn a0 < b1 && b0 < a1\n}\n\n/**\n * Finds the intersection of two ranges.\n *\n * @param a0 - The start point in the A range\n * @param a1 - The end point in the A range\n * @param b0 - The start point in the B range\n * @param b1 - The end point in the B range\n * @returns The intersection of the ranges, or null if no intersection\n * @public\n */\nexport function rangeIntersection(\n\ta0: number,\n\ta1: number,\n\tb0: number,\n\tb1: number\n): [number, number] | null {\n\tconst min = Math.max(a0, b0)\n\tconst max = Math.min(a1, b1)\n\tif (min <= max) {\n\t\treturn [min, max]\n\t}\n\treturn null\n}\n\n/** Helper for point in polygon */\nfunction cross(x: VecLike, y: VecLike, z: VecLike): number {\n\treturn (y.x - x.x) * (z.y - x.y) - (z.x - x.x) * (y.y - x.y)\n}\n\n/**\n * Get whether a point is inside of a polygon.\n *\n * ```ts\n * const result = pointInPolygon(myPoint, myPoints)\n * ```\n *\n * @public\n */\nexport function pointInPolygon(A: VecLike, points: VecLike[]): boolean {\n\tlet windingNumber = 0\n\tlet a: VecLike\n\tlet b: VecLike\n\n\tfor (let i = 0; i < points.length; i++) {\n\t\ta = points[i]\n\t\t// Point is the same as one of the corners of the polygon\n\t\tif (a.x === A.x && a.y === A.y) return true\n\n\t\tb = points[(i + 1) % points.length]\n\n\t\t// Point is on the polygon edge\n\t\tif (Vec.Dist(A, a) + Vec.Dist(A, b) === Vec.Dist(a, b)) return true\n\n\t\tif (a.y <= A.y) {\n\t\t\tif (b.y > A.y && cross(a, b, A) > 0) {\n\t\t\t\twindingNumber += 1\n\t\t\t}\n\t\t} else if (b.y <= A.y && cross(a, b, A) < 0) {\n\t\t\twindingNumber -= 1\n\t\t}\n\t}\n\n\treturn windingNumber !== 0\n}\n\n/**\n * The DOM likes values to be fixed to 3 decimal places\n *\n * @public\n */\nexport function toDomPrecision(v: number) {\n\treturn Math.round(v * 1e4) / 1e4\n}\n\n/**\n * @public\n */\nexport function toFixed(v: number) {\n\treturn Math.round(v * 1e2) / 1e2\n}\n\n/**\n * Check if a float is safe to use. ie: Not too big or small.\n * @public\n */\nexport const isSafeFloat = (n: number) => {\n\treturn Math.abs(n) < Number.MAX_SAFE_INTEGER\n}\n\n/**\n * Get the angle of a point on an arc.\n * @param fromAngle - The angle from center to arc's start point (A) on the circle\n * @param toAngle - The angle from center to arc's end point (B) on the circle\n * @param direction - The direction of the arc (1 = counter-clockwise, -1 = clockwise)\n * @returns The distance in radians between the two angles according to the direction\n * @public\n */\nexport function angleDistance(fromAngle: number, toAngle: number, direction: number) {\n\tconst dist =\n\t\tdirection < 0\n\t\t\t? clockwiseAngleDist(fromAngle, toAngle)\n\t\t\t: counterClockwiseAngleDist(fromAngle, toAngle)\n\treturn dist\n}\n\n/**\n * Returns the t value of the point on the arc.\n *\n * @param mAB - The measure of the arc from A to B, negative if counter-clockwise\n * @param A - The angle from center to arc's start point (A) on the circle\n * @param B - The angle from center to arc's end point (B) on the circle\n * @param P - The angle on the circle (P) to find the t value for\n *\n * @returns The t value of the point on the arc, with 0 being the start and 1 being the end\n *\n * @public\n */\nexport function getPointInArcT(mAB: number, A: number, B: number, P: number): number {\n\tlet mAP: number\n\tif (Math.abs(mAB) > PI) {\n\t\tmAP = shortAngleDist(A, P)\n\t\tconst mPB = shortAngleDist(P, B)\n\t\tif (Math.abs(mAP) < Math.abs(mPB)) {\n\t\t\treturn mAP / mAB\n\t\t} else {\n\t\t\treturn (mAB - mPB) / mAB\n\t\t}\n\t} else {\n\t\tmAP = shortAngleDist(A, P)\n\t\tconst t = mAP / mAB\n\n\t\t// If the arc is something like -2.8 to 2.2, then we'll get a weird bug\n\t\t// where the measurement to the center is negative but measure to points\n\t\t// near the end are positive\n\t\tif (Math.sign(mAP) !== Math.sign(mAB)) {\n\t\t\treturn Math.abs(t) > 0.5 ? 1 : 0\n\t\t}\n\n\t\treturn t\n\t}\n}\n\n/**\n * Get the measure of an arc.\n *\n * @param A - The angle from center to arc's start point (A) on the circle\n * @param B - The angle from center to arc's end point (B) on the circle\n * @param sweepFlag - 1 if the arc is clockwise, 0 if counter-clockwise\n * @param largeArcFlag - 1 if the arc is greater than 180 degrees, 0 if less than 180 degrees\n *\n * @returns The measure of the arc, negative if counter-clockwise\n *\n * @public\n */\nexport function getArcMeasure(A: number, B: number, sweepFlag: number, largeArcFlag: number) {\n\tconst m = ((2 * ((B - A) % PI2)) % PI2) - ((B - A) % PI2)\n\tif (!largeArcFlag) return m\n\treturn (PI2 - Math.abs(m)) * (sweepFlag ? 1 : -1)\n}\n\n/**\n * Get the center of a circle from three points.\n *\n * @param a - The first point\n * @param b - The second point\n * @param c - The third point\n *\n * @returns The center of the circle or null if the points are collinear\n *\n * @public\n */\nexport function centerOfCircleFromThreePoints(a: VecLike, b: VecLike, c: VecLike) {\n\tconst u = -2 * (a.x * (b.y - c.y) - a.y * (b.x - c.x) + b.x * c.y - c.x * b.y)\n\tconst x =\n\t\t((a.x * a.x + a.y * a.y) * (c.y - b.y) +\n\t\t\t(b.x * b.x + b.y * b.y) * (a.y - c.y) +\n\t\t\t(c.x * c.x + c.y * c.y) * (b.y - a.y)) /\n\t\tu\n\tconst y =\n\t\t((a.x * a.x + a.y * a.y) * (b.x - c.x) +\n\t\t\t(b.x * b.x + b.y * b.y) * (c.x - a.x) +\n\t\t\t(c.x * c.x + c.y * c.y) * (a.x - b.x)) /\n\t\tu\n\tif (!Number.isFinite(x) || !Number.isFinite(y)) {\n\t\treturn null\n\t}\n\treturn new Vec(x, y)\n}\n\n/** @public */\nexport function getPointsOnArc(\n\tstartPoint: VecLike,\n\tendPoint: VecLike,\n\tcenter: VecLike | null,\n\tradius: number,\n\tnumPoints: number\n): Vec[] {\n\tif (center === null) {\n\t\treturn [Vec.From(startPoint), Vec.From(endPoint)]\n\t}\n\tconst results: Vec[] = []\n\tconst startAngle = Vec.Angle(center, startPoint)\n\tconst endAngle = Vec.Angle(center, endPoint)\n\tconst l = clockwiseAngleDist(startAngle, endAngle)\n\tfor (let i = 0; i < numPoints; i++) {\n\t\tconst t = i / (numPoints - 1)\n\t\tconst angle = startAngle + l * t\n\t\tconst point = getPointOnCircle(center, radius, angle)\n\t\tresults.push(point)\n\t}\n\treturn results\n}\n"],
  "mappings": "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",
  "names": []
}
