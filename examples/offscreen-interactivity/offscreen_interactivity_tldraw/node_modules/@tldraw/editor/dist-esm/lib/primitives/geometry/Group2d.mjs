import { Box } from "../Box.mjs";
import { Vec } from "../Vec.mjs";
import { Geometry2d } from "./Geometry2d.mjs";
class Group2d extends Geometry2d {
  children = [];
  ignoredChildren = [];
  constructor(config) {
    super({ ...config, isClosed: true, isFilled: false });
    for (const child of config.children) {
      if (child.ignore) {
        this.ignoredChildren.push(child);
      } else {
        this.children.push(child);
      }
    }
    if (this.children.length === 0) throw Error("Group2d must have at least one child");
  }
  getVertices() {
    return this.children.filter((c) => !c.isLabel).flatMap((c) => c.vertices);
  }
  nearestPoint(point) {
    let dist = Infinity;
    let nearest;
    const { children } = this;
    if (children.length === 0) {
      throw Error("no children");
    }
    let p;
    let d;
    for (const child of children) {
      p = child.nearestPoint(point);
      d = Vec.Dist2(p, point);
      if (d < dist) {
        dist = d;
        nearest = p;
      }
    }
    if (!nearest) throw Error("nearest point not found");
    return nearest;
  }
  distanceToPoint(point, hitInside = false) {
    return Math.min(...this.children.map((c, i) => c.distanceToPoint(point, hitInside || i > 0)));
  }
  hitTestPoint(point, margin, hitInside) {
    return !!this.children.filter((c) => !c.isLabel).find((c) => c.hitTestPoint(point, margin, hitInside));
  }
  hitTestLineSegment(A, B, zoom) {
    return !!this.children.filter((c) => !c.isLabel).find((c) => c.hitTestLineSegment(A, B, zoom));
  }
  getArea() {
    return this.children[0].area;
  }
  toSimpleSvgPath() {
    let path = "";
    for (const child of this.children) {
      path += child.toSimpleSvgPath();
    }
    const corners = Box.FromPoints(this.vertices).corners;
    for (let i = 0, n = corners.length; i < n; i++) {
      const corner = corners[i];
      const prevCorner = corners[(i - 1 + n) % n];
      const prevDist = corner.dist(prevCorner);
      const nextCorner = corners[(i + 1) % n];
      const nextDist = corner.dist(nextCorner);
      const A = corner.clone().lrp(prevCorner, 4 / prevDist);
      const B = corner;
      const C = corner.clone().lrp(nextCorner, 4 / nextDist);
      path += `M${A.x},${A.y} L${B.x},${B.y} L${C.x},${C.y} `;
    }
    return path;
  }
  getLength() {
    return this.children.reduce((a, c) => c.isLabel ? a : a + c.length, 0);
  }
  getSvgPathData() {
    return this.children.map((c, i) => c.isLabel ? "" : c.getSvgPathData(i === 0)).join(" ");
  }
}
export {
  Group2d
};
//# sourceMappingURL=Group2d.mjs.map
