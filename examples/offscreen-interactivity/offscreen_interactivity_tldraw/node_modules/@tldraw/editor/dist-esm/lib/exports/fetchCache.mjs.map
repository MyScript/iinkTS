{
  "version": 3,
  "sources": ["../../../src/lib/exports/fetchCache.ts"],
  "sourcesContent": ["import { FileHelpers, assert, fetch } from '@tldraw/utils'\n\n// TODO(alex): currently, this cache will grow unbounded. we should come up with a better strategy\n// for clearing items from the cache over time.\nexport function fetchCache<T>(cb: (response: Response) => Promise<T>, init?: RequestInit) {\n\tconst cache = new Map<string, Promise<T | null>>()\n\n\treturn async function fetchCached(url: string): Promise<T | null> {\n\t\tconst existing = cache.get(url)\n\t\tif (existing) return existing\n\n\t\tconst promise = (async () => {\n\t\t\ttry {\n\t\t\t\tconst response = await fetch(url, init)\n\t\t\t\tassert(response.ok)\n\t\t\t\treturn await cb(response)\n\t\t\t} catch (err) {\n\t\t\t\tconsole.error(err)\n\t\t\t\treturn null\n\t\t\t}\n\t\t})()\n\t\tcache.set(url, promise)\n\t\treturn promise\n\t}\n}\n\nexport const resourceToDataUrl = fetchCache(async (response) => {\n\treturn await FileHelpers.blobToDataUrl(await response.blob())\n})\n"],
  "mappings": "AAAA,SAAS,aAAa,QAAQ,aAAa;AAIpC,SAAS,WAAc,IAAwC,MAAoB;AACzF,QAAM,QAAQ,oBAAI,IAA+B;AAEjD,SAAO,eAAe,YAAY,KAAgC;AACjE,UAAM,WAAW,MAAM,IAAI,GAAG;AAC9B,QAAI,SAAU,QAAO;AAErB,UAAM,WAAW,YAAY;AAC5B,UAAI;AACH,cAAM,WAAW,MAAM,MAAM,KAAK,IAAI;AACtC,eAAO,SAAS,EAAE;AAClB,eAAO,MAAM,GAAG,QAAQ;AAAA,MACzB,SAAS,KAAK;AACb,gBAAQ,MAAM,GAAG;AACjB,eAAO;AAAA,MACR;AAAA,IACD,GAAG;AACH,UAAM,IAAI,KAAK,OAAO;AACtB,WAAO;AAAA,EACR;AACD;AAEO,MAAM,oBAAoB,WAAW,OAAO,aAAa;AAC/D,SAAO,MAAM,YAAY,cAAc,MAAM,SAAS,KAAK,CAAC;AAC7D,CAAC;",
  "names": []
}
