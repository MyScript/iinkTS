{
  "version": 3,
  "sources": ["../../../../src/lib/editor/types/SvgExportContext.tsx"],
  "sourcesContent": ["import { promiseWithResolve } from '@tldraw/utils'\nimport { ReactElement, ReactNode, createContext, useContext, useEffect, useState } from 'react'\nimport { ContainerProvider } from '../../hooks/useContainer'\nimport { EditorProvider } from '../../hooks/useEditor'\nimport { useEvent } from '../../hooks/useEvent'\nimport { Editor } from '../Editor'\n\n/** @public */\nexport interface SvgExportDef {\n\tkey: string\n\tgetElement(): Promise<ReactElement | null> | ReactElement | null\n}\n\n/** @public */\nexport interface SvgExportContext {\n\t/**\n\t * Add contents to the `<defs>` section of the export SVG. Each export def should have a unique\n\t * key. If multiple defs come with the same key, only one will be added.\n\t */\n\taddExportDef(def: SvgExportDef): void\n\n\t/**\n\t * Cause the SVG export to be delayed until the returned promise is resolved. This is useful if\n\t * e.g. your shape loads data dynamically, and you need to prevent the export from happening\n\t * until after the data is loaded.\n\t *\n\t * See also the {@link useDelaySvgExport} hook, which may be a more convenient way to use this\n\t * method depending on your use-case.\n\t */\n\twaitUntil(promise: Promise<void>): void\n\n\t/**\n\t * Whether the export should be in dark mode.\n\t */\n\treadonly isDarkMode: boolean\n}\n\nconst Context = createContext<SvgExportContext | null>(null)\nexport function SvgExportContextProvider({\n\tcontext,\n\teditor,\n\tchildren,\n}: {\n\tcontext: SvgExportContext\n\teditor: Editor\n\tchildren: ReactNode\n}) {\n\tconst Provider = editor.options.exportProvider\n\n\treturn (\n\t\t<EditorProvider editor={editor}>\n\t\t\t<ContainerProvider container={editor.getContainer()}>\n\t\t\t\t<Context.Provider value={context}>\n\t\t\t\t\t<Provider>{children}</Provider>\n\t\t\t\t</Context.Provider>\n\t\t\t</ContainerProvider>\n\t\t</EditorProvider>\n\t)\n}\n\n/**\n * Returns the current SVG export context. Returns null if the component isn't being rendered for an\n * SVG export.\n *\n * @public\n */\nexport function useSvgExportContext() {\n\treturn useContext(Context)\n}\n\n/**\n * Delay an SVG export until the returned function is called. This is useful if e.g. your shape\n * loads data dynamically, and you need to prevent the export from happening until after the data is\n * loaded.\n *\n * If used outside of an SVG export, this hook has no effect.\n *\n * @example\n * ```tsx\n * const readyForExport = useDelaySvgExport()\n *\n * return <MyDynamicComponent onDataLoaded={() => readyForExport()} />\n * ```\n *\n * @public\n */\nexport function useDelaySvgExport() {\n\tconst ctx = useContext(Context)\n\tconst [promise] = useState(promiseWithResolve<void>)\n\n\tuseEffect(() => {\n\t\tctx?.waitUntil(promise)\n\t\treturn () => {\n\t\t\tpromise.resolve()\n\t\t}\n\t}, [promise, ctx])\n\n\treturn useEvent(() => {\n\t\tpromise.resolve()\n\t})\n}\n"],
  "mappings": "AAqDK;AArDL,SAAS,0BAA0B;AACnC,SAAkC,eAAe,YAAY,WAAW,gBAAgB;AACxF,SAAS,yBAAyB;AAClC,SAAS,sBAAsB;AAC/B,SAAS,gBAAgB;AAiCzB,MAAM,UAAU,cAAuC,IAAI;AACpD,SAAS,yBAAyB;AAAA,EACxC;AAAA,EACA;AAAA,EACA;AACD,GAIG;AACF,QAAM,WAAW,OAAO,QAAQ;AAEhC,SACC,oBAAC,kBAAe,QACf,8BAAC,qBAAkB,WAAW,OAAO,aAAa,GACjD,8BAAC,QAAQ,UAAR,EAAiB,OAAO,SACxB,8BAAC,YAAU,UAAS,GACrB,GACD,GACD;AAEF;AAQO,SAAS,sBAAsB;AACrC,SAAO,WAAW,OAAO;AAC1B;AAkBO,SAAS,oBAAoB;AACnC,QAAM,MAAM,WAAW,OAAO;AAC9B,QAAM,CAAC,OAAO,IAAI,SAAS,kBAAwB;AAEnD,YAAU,MAAM;AACf,SAAK,UAAU,OAAO;AACtB,WAAO,MAAM;AACZ,cAAQ,QAAQ;AAAA,IACjB;AAAA,EACD,GAAG,CAAC,SAAS,GAAG,CAAC;AAEjB,SAAO,SAAS,MAAM;AACrB,YAAQ,QAAQ;AAAA,EACjB,CAAC;AACF;",
  "names": []
}
