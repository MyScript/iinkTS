{
  "version": 3,
  "sources": ["../../../../src/lib/editor/managers/TickManager.ts"],
  "sourcesContent": ["import { throttleToNextFrame as _throttleToNextFrame, bind } from '@tldraw/utils'\nimport { Vec } from '../../primitives/Vec'\nimport { Editor } from '../Editor'\n\nconst throttleToNextFrame =\n\ttypeof process !== 'undefined' && process.env.NODE_ENV === 'test'\n\t\t? // At test time we should use actual raf and not throttle, because throttle was set up to evaluate immediately during tests, which causes stack overflow\n\t\t\t// for the tick manager since it sets up a raf loop.\n\t\t\tfunction mockThrottle(cb: any) {\n\t\t\t\t// eslint-disable-next-line no-restricted-globals\n\t\t\t\tconst frame = requestAnimationFrame(cb)\n\t\t\t\treturn () => cancelAnimationFrame(frame)\n\t\t\t}\n\t\t: _throttleToNextFrame\n\nexport class TickManager {\n\tconstructor(public editor: Editor) {\n\t\tthis.editor.disposables.add(this.dispose)\n\t\tthis.start()\n\t}\n\n\tcancelRaf?: null | (() => void)\n\tisPaused = true\n\tnow = 0\n\n\tstart() {\n\t\tthis.isPaused = false\n\t\tthis.cancelRaf?.()\n\t\tthis.cancelRaf = throttleToNextFrame(this.tick)\n\t\tthis.now = Date.now()\n\t}\n\n\t@bind\n\ttick() {\n\t\tif (this.isPaused) {\n\t\t\treturn\n\t\t}\n\n\t\tconst now = Date.now()\n\t\tconst elapsed = now - this.now\n\t\tthis.now = now\n\n\t\tthis.updatePointerVelocity(elapsed)\n\t\tthis.editor.emit('frame', elapsed)\n\t\tthis.editor.emit('tick', elapsed)\n\t\tthis.cancelRaf = throttleToNextFrame(this.tick)\n\t}\n\n\t// Clear the listener\n\t@bind\n\tdispose() {\n\t\tthis.isPaused = true\n\n\t\tthis.cancelRaf?.()\n\t}\n\n\tprivate prevPoint = new Vec()\n\n\tupdatePointerVelocity(elapsed: number) {\n\t\tconst {\n\t\t\tprevPoint,\n\t\t\teditor: {\n\t\t\t\tinputs: { currentScreenPoint, pointerVelocity },\n\t\t\t},\n\t\t} = this\n\n\t\tif (elapsed === 0) return\n\n\t\tconst delta = Vec.Sub(currentScreenPoint, prevPoint)\n\t\tthis.prevPoint = currentScreenPoint.clone()\n\n\t\tconst length = delta.len()\n\t\tconst direction = length ? delta.div(length) : new Vec(0, 0)\n\n\t\t// consider adjusting this with an easing rather than a linear interpolation\n\t\tconst next = pointerVelocity.clone().lrp(direction.mul(length / elapsed), 0.5)\n\n\t\t// if the velocity is very small, just set it to 0\n\t\tif (Math.abs(next.x) < 0.01) next.x = 0\n\t\tif (Math.abs(next.y) < 0.01) next.y = 0\n\n\t\tif (!pointerVelocity.equals(next)) {\n\t\t\tthis.editor.inputs.pointerVelocity = next\n\t\t}\n\t}\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAkE;AAClE,iBAAoB;AADpB;AAIA,MAAM,sBACL,OAAO,YAAY,eAAe,QAAQ,IAAI,aAAa;AAAA;AAAA;AAAA,EAGzD,SAAS,aAAa,IAAS;AAE9B,UAAM,QAAQ,sBAAsB,EAAE;AACtC,WAAO,MAAM,qBAAqB,KAAK;AAAA,EACxC;AAAA,IACC,aAAAA;AAmBH,aAAC,oBAiBD,gBAAC;AAlCK,MAAM,YAAY;AAAA,EACxB,YAAmB,QAAgB;AAAhB;AADb;AAMN;AACA,oCAAW;AACX,+BAAM;AAiCN,wBAAQ,aAAY,IAAI,eAAI;AAvC3B,SAAK,OAAO,YAAY,IAAI,KAAK,OAAO;AACxC,SAAK,MAAM;AAAA,EACZ;AAAA,EAMA,QAAQ;AACP,SAAK,WAAW;AAChB,SAAK,YAAY;AACjB,SAAK,YAAY,oBAAoB,KAAK,IAAI;AAC9C,SAAK,MAAM,KAAK,IAAI;AAAA,EACrB;AAAA,EAGA,OAAO;AACN,QAAI,KAAK,UAAU;AAClB;AAAA,IACD;AAEA,UAAM,MAAM,KAAK,IAAI;AACrB,UAAM,UAAU,MAAM,KAAK;AAC3B,SAAK,MAAM;AAEX,SAAK,sBAAsB,OAAO;AAClC,SAAK,OAAO,KAAK,SAAS,OAAO;AACjC,SAAK,OAAO,KAAK,QAAQ,OAAO;AAChC,SAAK,YAAY,oBAAoB,KAAK,IAAI;AAAA,EAC/C;AAAA,EAIA,UAAU;AACT,SAAK,WAAW;AAEhB,SAAK,YAAY;AAAA,EAClB;AAAA,EAIA,sBAAsB,SAAiB;AACtC,UAAM;AAAA,MACL;AAAA,MACA,QAAQ;AAAA,QACP,QAAQ,EAAE,oBAAoB,gBAAgB;AAAA,MAC/C;AAAA,IACD,IAAI;AAEJ,QAAI,YAAY,EAAG;AAEnB,UAAM,QAAQ,eAAI,IAAI,oBAAoB,SAAS;AACnD,SAAK,YAAY,mBAAmB,MAAM;AAE1C,UAAM,SAAS,MAAM,IAAI;AACzB,UAAM,YAAY,SAAS,MAAM,IAAI,MAAM,IAAI,IAAI,eAAI,GAAG,CAAC;AAG3D,UAAM,OAAO,gBAAgB,MAAM,EAAE,IAAI,UAAU,IAAI,SAAS,OAAO,GAAG,GAAG;AAG7E,QAAI,KAAK,IAAI,KAAK,CAAC,IAAI,KAAM,MAAK,IAAI;AACtC,QAAI,KAAK,IAAI,KAAK,CAAC,IAAI,KAAM,MAAK,IAAI;AAEtC,QAAI,CAAC,gBAAgB,OAAO,IAAI,GAAG;AAClC,WAAK,OAAO,OAAO,kBAAkB;AAAA,IACtC;AAAA,EACD;AACD;AAtEO;AAkBN,oCADA,WAjBY;AAmCZ,uCADA,cAlCY;AAAN,2BAAM;",
  "names": ["_throttleToNextFrame"]
}
