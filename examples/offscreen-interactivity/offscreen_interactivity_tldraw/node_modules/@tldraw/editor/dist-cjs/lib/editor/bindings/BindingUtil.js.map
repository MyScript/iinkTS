{
  "version": 3,
  "sources": ["../../../../src/lib/editor/bindings/BindingUtil.ts"],
  "sourcesContent": ["import { RecordProps, TLPropsMigrations, TLShape, TLUnknownBinding } from '@tldraw/tlschema'\nimport { Editor } from '../Editor'\n\n/** @public */\nexport interface TLBindingUtilConstructor<\n\tT extends TLUnknownBinding,\n\tU extends BindingUtil<T> = BindingUtil<T>,\n> {\n\tnew (editor: Editor): U\n\ttype: T['type']\n\t/** Validations for this binding's props. */\n\tprops?: RecordProps<T>\n\t/** Migrations for this binding's props. */\n\tmigrations?: TLPropsMigrations\n}\n\n/**\n * Options passed to {@link BindingUtil.onBeforeCreate} and {@link BindingUtil.onAfterCreate},\n * describing a the creating a binding.\n *\n * @public\n */\nexport interface BindingOnCreateOptions<Binding extends TLUnknownBinding> {\n\t/** The binding being created. */\n\tbinding: Binding\n}\n\n/**\n * Options passed to {@link BindingUtil.onBeforeChange} and {@link BindingUtil.onAfterChange},\n * describing the data associated with a binding being changed.\n *\n * @public\n */\nexport interface BindingOnChangeOptions<Binding extends TLUnknownBinding> {\n\t/** The binding record before the change is made. */\n\tbindingBefore: Binding\n\t/** The binding record after the change is made. */\n\tbindingAfter: Binding\n}\n\n/**\n * Options passed to {@link BindingUtil.onBeforeDelete} and {@link BindingUtil.onAfterDelete},\n * describing a binding being deleted.\n *\n * @public\n */\nexport interface BindingOnDeleteOptions<Binding extends TLUnknownBinding> {\n\t/** The binding being deleted. */\n\tbinding: Binding\n}\n\n/**\n * Options passed to {@link BindingUtil.onAfterChangeFromShape} and\n * {@link BindingUtil.onAfterChangeToShape}, describing a bound shape being changed.\n *\n * @public\n */\nexport interface BindingOnShapeChangeOptions<Binding extends TLUnknownBinding> {\n\t/** The binding record linking these two shapes. */\n\tbinding: Binding\n\t/** The shape record before the change is made. */\n\tshapeBefore: TLShape\n\t/** The shape record after the change is made. */\n\tshapeAfter: TLShape\n}\n\n/**\n * Options passed to {@link BindingUtil.onBeforeIsolateFromShape} and\n * {@link BindingUtil.onBeforeIsolateToShape}, describing a shape that is about to be isolated from\n * the one that it's bound to.\n *\n * Isolation happens whenever two bound shapes are separated. For example\n * 1. One is deleted, but the other is not.\n * 1. One is copied, but the other is not.\n * 1. One is duplicated, but the other is not.\n *\n * In each of these cases, if the remaining shape depends on the binding for its rendering, it may\n * now be in an inconsistent state. For example, tldraw's arrow shape depends on the binding to know\n * where the end of the arrow is. If we removed the binding without doing anything else, the arrow\n * would suddenly be pointing to the wrong location. Instead, when the shape the arrow is pointing\n * to is deleted, or the arrow is copied/duplicated, we use an isolation callback. The callback\n * updates the arrow based on the binding that's about to be removed, so it doesn't end up pointing\n * to the wrong place.\n *\n * For this style of consistency update, use isolation callbacks. For actions specific to deletion\n * (like deleting a sticker when the shape it's bound to is removed), use the delete callbacks\n * ({@link BindingUtil.onBeforeDeleteFromShape} and {@link BindingUtil.onBeforeDeleteToShape})\n * instead.\n *\n * @public\n */\nexport interface BindingOnShapeIsolateOptions<Binding extends TLUnknownBinding> {\n\t/** The binding record that refers to the shape in question. */\n\tbinding: Binding\n\t/**\n\t * The shape being removed. For deletion, this is the deleted shape. For copy/duplicate, this is\n\t * the shape that _isn't_ being copied/duplicated and is getting left behind.\n\t */\n\tremovedShape: TLShape\n}\n\n/**\n * Options passed to {@link BindingUtil.onBeforeDeleteFromShape} and\n * {@link BindingUtil.onBeforeDeleteToShape}, describing a bound shape that is about to be deleted.\n *\n * See {@link BindingOnShapeIsolateOptions} for discussion on when to use the delete vs. the isolate\n * callbacks.\n *\n * @public\n */\nexport interface BindingOnShapeDeleteOptions<Binding extends TLUnknownBinding> {\n\t/** The binding record that refers to the shape in question. */\n\tbinding: Binding\n\t/** The shape that is about to be deleted. */\n\tshape: TLShape\n}\n\n/** @public */\nexport abstract class BindingUtil<Binding extends TLUnknownBinding = TLUnknownBinding> {\n\tconstructor(public editor: Editor) {}\n\tstatic props?: RecordProps<TLUnknownBinding>\n\tstatic migrations?: TLPropsMigrations\n\n\t/**\n\t * The type of the binding util, which should match the binding's type.\n\t *\n\t * @public\n\t */\n\tstatic type: string\n\n\t/**\n\t * Get the default props for a binding.\n\t *\n\t * @public\n\t */\n\tabstract getDefaultProps(): Partial<Binding['props']>\n\n\t/**\n\t * Called whenever a store operation involving this binding type has completed. This is useful\n\t * for working with networks of related bindings that may need to update together.\n\t *\n\t * @example\n\t * ```ts\n\t * class MyBindingUtil extends BindingUtil<MyBinding> {\n\t *   changedBindingIds = new Set<TLBindingId>()\n\t *\n\t *   onOperationComplete() {\n\t *     doSomethingWithChangedBindings(this.changedBindingIds)\n\t *     this.changedBindingIds.clear()\n\t *   }\n\t *\n\t *   onAfterChange({ bindingAfter }: BindingOnChangeOptions<MyBinding>) {\n\t *     this.changedBindingIds.add(bindingAfter.id)\n\t *   }\n\t * }\n\t * ```\n\t *\n\t * @public\n\t */\n\tonOperationComplete?(): void\n\n\t/**\n\t * Called when a binding is about to be created. See {@link BindingOnCreateOptions} for details.\n\t *\n\t * You can optionally return a new binding to replace the one being created - for example, to\n\t * set different initial props.\n\t *\n\t * @public\n\t */\n\tonBeforeCreate?(options: BindingOnCreateOptions<Binding>): Binding | void\n\n\t/**\n\t * Called after a binding has been created. See {@link BindingOnCreateOptions} for details.\n\t *\n\t * @public\n\t */\n\tonAfterCreate?(options: BindingOnCreateOptions<Binding>): void\n\n\t/**\n\t * Called when a binding is about to be changed. See {@link BindingOnChangeOptions} for details.\n\t *\n\t * Note that this only fires when the binding record is changing, not when the shapes\n\t * associated change. Use {@link BindingUtil.onAfterChangeFromShape} and\n\t * {@link BindingUtil.onAfterChangeToShape} for that.\n\t *\n\t * You can optionally return a new binding to replace the one being changed - for example, to\n\t * enforce constraints on the binding's props.\n\t *\n\t * @public\n\t */\n\tonBeforeChange?(options: BindingOnChangeOptions<Binding>): Binding | void\n\n\t/**\n\t * Called after a binding has been changed. See {@link BindingOnChangeOptions} for details.\n\t *\n\t * Note that this only fires when the binding record is changing, not when the shapes\n\t * associated change. Use {@link BindingUtil.onAfterChangeFromShape} and\n\t * {@link BindingUtil.onAfterChangeToShape} for that.\n\t *\n\t * @public\n\t */\n\tonAfterChange?(options: BindingOnChangeOptions<Binding>): void\n\n\t/**\n\t * Called when a binding is about to be deleted. See {@link BindingOnDeleteOptions} for details.\n\t *\n\t * @public\n\t */\n\tonBeforeDelete?(options: BindingOnDeleteOptions<Binding>): void\n\n\t/**\n\t * Called after a binding has been deleted. See {@link BindingOnDeleteOptions} for details.\n\t *\n\t * @public\n\t */\n\tonAfterDelete?(options: BindingOnDeleteOptions<Binding>): void\n\n\t/**\n\t * Called after the shape referenced in a binding's `fromId` is changed. Use this to propagate\n\t * any changes to the binding itself or the other shape as needed. See\n\t * {@link BindingOnShapeChangeOptions} for details.\n\t *\n\t * @public\n\t */\n\tonAfterChangeFromShape?(options: BindingOnShapeChangeOptions<Binding>): void\n\n\t/**\n\t * Called after the shape referenced in a binding's `toId` is changed. Use this to propagate any\n\t * changes to the binding itself or the other shape as needed. See\n\t * {@link BindingOnShapeChangeOptions} for details.\n\t *\n\t * @public\n\t */\n\tonAfterChangeToShape?(options: BindingOnShapeChangeOptions<Binding>): void\n\n\t/**\n\t * Called before the shape referenced in a binding's `fromId` is about to be deleted. Use this\n\t * with care - you may want to use {@link BindingUtil.onBeforeIsolateToShape} instead. See\n\t * {@link BindingOnShapeDeleteOptions} for details.\n\t *\n\t * @public\n\t */\n\tonBeforeDeleteFromShape?(options: BindingOnShapeDeleteOptions<Binding>): void\n\t/**\n\t * Called before the shape referenced in a binding's `toId` is about to be deleted. Use this\n\t * with care - you may want to use {@link BindingUtil.onBeforeIsolateFromShape} instead. See\n\t * {@link BindingOnShapeDeleteOptions} for details.\n\t *\n\t * @public\n\t */\n\tonBeforeDeleteToShape?(options: BindingOnShapeDeleteOptions<Binding>): void\n\n\t/**\n\t * Called before the shape referenced in a binding's `fromId` is about to be isolated from the\n\t * shape referenced in `toId`. See {@link BindingOnShapeIsolateOptions} for discussion on what\n\t * isolation means, and when/how to use this callback.\n\t */\n\tonBeforeIsolateFromShape?(options: BindingOnShapeIsolateOptions<Binding>): void\n\n\t/**\n\t * Called before the shape referenced in a binding's `toId` is about to be isolated from the\n\t * shape referenced in `fromId`. See {@link BindingOnShapeIsolateOptions} for discussion on what\n\t * isolation means, and when/how to use this callback.\n\t */\n\tonBeforeIsolateToShape?(options: BindingOnShapeIsolateOptions<Binding>): void\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAsHO,MAAe,YAAiE;AAAA,EACtF,YAAmB,QAAgB;AAAhB;AAAA,EAAiB;AAAA,EACpC,OAAO;AAAA,EACP,OAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOP,OAAO;AAyIR;",
  "names": []
}
