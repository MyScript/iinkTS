{
  "version": 3,
  "sources": ["../../src/lib/array.ts"],
  "sourcesContent": ["/**\n * Rotate the contents of an array.\n *\n * @public\n */\nexport function rotateArray<T>(arr: T[], offset: number): T[] {\n\treturn arr.map((_, i) => arr[(i + offset) % arr.length])\n}\n\n/**\n * Deduplicate the items in an array\n *\n * @public\n */\nexport function dedupe<T>(input: T[], equals?: (a: any, b: any) => boolean): T[] {\n\tconst result: T[] = []\n\tmainLoop: for (const item of input) {\n\t\tfor (const existing of result) {\n\t\t\tif (equals ? equals(item, existing) : item === existing) {\n\t\t\t\tcontinue mainLoop\n\t\t\t}\n\t\t}\n\t\tresult.push(item)\n\t}\n\treturn result\n}\n\n/** @internal */\nexport function compact<T>(arr: T[]): NonNullable<T>[] {\n\treturn arr.filter((i) => i !== undefined && i !== null) as any\n}\n\n/** @internal */\nexport function last<T>(arr: readonly T[]): T | undefined {\n\treturn arr[arr.length - 1]\n}\n\n/** @internal */\nexport function minBy<T>(arr: readonly T[], fn: (item: T) => number): T | undefined {\n\tlet min: T | undefined\n\tlet minVal = Infinity\n\tfor (const item of arr) {\n\t\tconst val = fn(item)\n\t\tif (val < minVal) {\n\t\t\tmin = item\n\t\t\tminVal = val\n\t\t}\n\t}\n\treturn min\n}\n\n/** @internal */\nexport function maxBy<T>(arr: readonly T[], fn: (item: T) => number): T | undefined {\n\tlet max: T | undefined\n\tlet maxVal: number = -Infinity\n\tfor (const item of arr) {\n\t\tconst val = fn(item)\n\t\tif (val > maxVal) {\n\t\t\tmax = item\n\t\t\tmaxVal = val\n\t\t}\n\t}\n\treturn max\n}\n\n/**\n * Partitions an array into two arrays, one with items that satisfy the predicate, and one with\n * items that do not.\n *\n * @param arr - The array to partition\n * @param predicate - The predicate to use to partition the array\n * @returns A tuple of two arrays, the first one with items that satisfy the predicate and the\n *   second one with the ones that dont\n * @internal\n */\nexport function partition<T>(arr: T[], predicate: (item: T) => boolean): [T[], T[]] {\n\tconst satisfies: T[] = []\n\tconst doesNotSatisfy: T[] = []\n\tfor (const item of arr) {\n\t\tif (predicate(item)) {\n\t\t\tsatisfies.push(item)\n\t\t} else {\n\t\t\tdoesNotSatisfy.push(item)\n\t\t}\n\t}\n\treturn [satisfies, doesNotSatisfy]\n}\n\n/** @internal */\nexport function areArraysShallowEqual<T>(arr1: readonly T[], arr2: readonly T[]): boolean {\n\tif (arr1 === arr2) return true\n\tif (arr1.length !== arr2.length) return false\n\tfor (let i = 0; i < arr1.length; i++) {\n\t\tif (!Object.is(arr1[i], arr2[i])) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n"],
  "mappings": "AAKO,SAAS,YAAe,KAAU,QAAqB;AAC7D,SAAO,IAAI,IAAI,CAAC,GAAG,MAAM,KAAK,IAAI,UAAU,IAAI,MAAM,CAAC;AACxD;AAOO,SAAS,OAAU,OAAY,QAA2C;AAChF,QAAM,SAAc,CAAC;AACrB,WAAU,YAAW,QAAQ,OAAO;AACnC,eAAW,YAAY,QAAQ;AAC9B,UAAI,SAAS,OAAO,MAAM,QAAQ,IAAI,SAAS,UAAU;AACxD,iBAAS;AAAA,MACV;AAAA,IACD;AACA,WAAO,KAAK,IAAI;AAAA,EACjB;AACA,SAAO;AACR;AAGO,SAAS,QAAW,KAA4B;AACtD,SAAO,IAAI,OAAO,CAAC,MAAM,MAAM,UAAa,MAAM,IAAI;AACvD;AAGO,SAAS,KAAQ,KAAkC;AACzD,SAAO,IAAI,IAAI,SAAS,CAAC;AAC1B;AAGO,SAAS,MAAS,KAAmB,IAAwC;AACnF,MAAI;AACJ,MAAI,SAAS;AACb,aAAW,QAAQ,KAAK;AACvB,UAAM,MAAM,GAAG,IAAI;AACnB,QAAI,MAAM,QAAQ;AACjB,YAAM;AACN,eAAS;AAAA,IACV;AAAA,EACD;AACA,SAAO;AACR;AAGO,SAAS,MAAS,KAAmB,IAAwC;AACnF,MAAI;AACJ,MAAI,SAAiB;AACrB,aAAW,QAAQ,KAAK;AACvB,UAAM,MAAM,GAAG,IAAI;AACnB,QAAI,MAAM,QAAQ;AACjB,YAAM;AACN,eAAS;AAAA,IACV;AAAA,EACD;AACA,SAAO;AACR;AAYO,SAAS,UAAa,KAAU,WAA6C;AACnF,QAAM,YAAiB,CAAC;AACxB,QAAM,iBAAsB,CAAC;AAC7B,aAAW,QAAQ,KAAK;AACvB,QAAI,UAAU,IAAI,GAAG;AACpB,gBAAU,KAAK,IAAI;AAAA,IACpB,OAAO;AACN,qBAAe,KAAK,IAAI;AAAA,IACzB;AAAA,EACD;AACA,SAAO,CAAC,WAAW,cAAc;AAClC;AAGO,SAAS,sBAAyB,MAAoB,MAA6B;AACzF,MAAI,SAAS,KAAM,QAAO;AAC1B,MAAI,KAAK,WAAW,KAAK,OAAQ,QAAO;AACxC,WAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACrC,QAAI,CAAC,OAAO,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC,GAAG;AACjC,aAAO;AAAA,IACR;AAAA,EACD;AACA,SAAO;AACR;",
  "names": []
}
