{
  "version": 3,
  "sources": ["../../src/lib/value.ts"],
  "sourcesContent": ["/**\n * Get whether a value is not undefined.\n *\n * @param value - The value to check.\n * @public\n */\nexport function isDefined<T>(value: T): value is typeof value extends undefined ? never : T {\n\treturn value !== undefined\n}\n\n/**\n * Get whether a value is null\n *\n * @param value - The value to check.\n * @public\n */\nexport function isNonNull<T>(value: T): value is typeof value extends null ? never : T {\n\treturn value !== null\n}\n\n/**\n * Get whether a value is nullish (null, undefined).\n *\n * @param value - The value to check.\n * @public\n */\nexport function isNonNullish<T>(\n\tvalue: T\n): value is typeof value extends undefined ? never : typeof value extends null ? never : T {\n\treturn value !== null && value !== undefined\n}\n\nfunction getStructuredClone(): [<T>(i: T) => T, boolean] {\n\tif (typeof globalThis !== 'undefined' && (globalThis as any).structuredClone) {\n\t\treturn [globalThis.structuredClone as <T>(i: T) => T, true]\n\t}\n\n\tif (typeof global !== 'undefined' && (global as any).structuredClone) {\n\t\treturn [global.structuredClone as <T>(i: T) => T, true]\n\t}\n\n\tif (typeof window !== 'undefined' && (window as any).structuredClone) {\n\t\treturn [window.structuredClone as <T>(i: T) => T, true]\n\t}\n\n\treturn [<T>(i: T): T => (i ? JSON.parse(JSON.stringify(i)) : i), false]\n}\n\nconst _structuredClone = getStructuredClone()\n\n/**\n * Create a deep copy of a value. Uses the structuredClone API if available, otherwise uses JSON.parse(JSON.stringify()).\n *\n * @param i - The value to clone.\n * @public */\nexport const structuredClone = _structuredClone[0]\n\n/**\n * @internal\n */\nexport const isNativeStructuredClone = _structuredClone[1]\n\n/**\n * When we patch structuredClone in jsdom for testing (see https://github.com/jsdom/jsdom/issues/3363),\n * the Object that is used as a prototype for the cloned object is not the same as the Object in\n * the code under test (that comes from jsdom's fake global context). This constant is used in\n * our code to work around this case.\n *\n * This is also the case for Array prototype, but that problem can be worked around with an\n * Array.isArray() check.\n * @internal\n */\nexport const STRUCTURED_CLONE_OBJECT_PROTOTYPE = Object.getPrototypeOf(structuredClone({}))\n"],
  "mappings": "AAMO,SAAS,UAAa,OAA+D;AAC3F,SAAO,UAAU;AAClB;AAQO,SAAS,UAAa,OAA0D;AACtF,SAAO,UAAU;AAClB;AAQO,SAAS,aACf,OAC0F;AAC1F,SAAO,UAAU,QAAQ,UAAU;AACpC;AAEA,SAAS,qBAAgD;AACxD,MAAI,OAAO,eAAe,eAAgB,WAAmB,iBAAiB;AAC7E,WAAO,CAAC,WAAW,iBAAmC,IAAI;AAAA,EAC3D;AAEA,MAAI,OAAO,WAAW,eAAgB,OAAe,iBAAiB;AACrE,WAAO,CAAC,OAAO,iBAAmC,IAAI;AAAA,EACvD;AAEA,MAAI,OAAO,WAAW,eAAgB,OAAe,iBAAiB;AACrE,WAAO,CAAC,OAAO,iBAAmC,IAAI;AAAA,EACvD;AAEA,SAAO,CAAC,CAAI,MAAa,IAAI,KAAK,MAAM,KAAK,UAAU,CAAC,CAAC,IAAI,GAAI,KAAK;AACvE;AAEA,MAAM,mBAAmB,mBAAmB;AAOrC,MAAM,kBAAkB,iBAAiB,CAAC;AAK1C,MAAM,0BAA0B,iBAAiB,CAAC;AAYlD,MAAM,oCAAoC,OAAO,eAAe,gBAAgB,CAAC,CAAC,CAAC;",
  "names": []
}
