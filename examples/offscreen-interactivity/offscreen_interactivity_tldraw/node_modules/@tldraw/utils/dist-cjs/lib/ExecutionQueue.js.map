{
  "version": 3,
  "sources": ["../../src/lib/ExecutionQueue.ts"],
  "sourcesContent": ["import { sleep } from './control'\n\n/** @internal */\nexport class ExecutionQueue {\n\tprivate queue: (() => Promise<any>)[] = []\n\tprivate running = false\n\n\tconstructor(private readonly timeout?: number) {}\n\n\tprivate async run() {\n\t\tif (this.running) return\n\t\ttry {\n\t\t\tthis.running = true\n\t\t\twhile (this.queue.length) {\n\t\t\t\tconst task = this.queue.shift()!\n\t\t\t\tawait task()\n\t\t\t\tif (this.timeout) {\n\t\t\t\t\tawait sleep(this.timeout)\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\t// this try/finally should not be needed because the tasks don't throw\n\t\t\t// but better safe than sorry\n\t\t\tthis.running = false\n\t\t}\n\t}\n\n\tasync push<T>(task: () => T): Promise<Awaited<T>> {\n\t\treturn new Promise<Awaited<T>>((resolve, reject) => {\n\t\t\tthis.queue.push(() => Promise.resolve(task()).then(resolve).catch(reject))\n\t\t\tthis.run()\n\t\t})\n\t}\n\n\tclose() {\n\t\tthis.queue = []\n\t}\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qBAAsB;AAGf,MAAM,eAAe;AAAA,EAI3B,YAA6B,SAAkB;AAAlB;AAAA,EAAmB;AAAA,EAHxC,QAAgC,CAAC;AAAA,EACjC,UAAU;AAAA,EAIlB,MAAc,MAAM;AACnB,QAAI,KAAK,QAAS;AAClB,QAAI;AACH,WAAK,UAAU;AACf,aAAO,KAAK,MAAM,QAAQ;AACzB,cAAM,OAAO,KAAK,MAAM,MAAM;AAC9B,cAAM,KAAK;AACX,YAAI,KAAK,SAAS;AACjB,oBAAM,sBAAM,KAAK,OAAO;AAAA,QACzB;AAAA,MACD;AAAA,IACD,UAAE;AAGD,WAAK,UAAU;AAAA,IAChB;AAAA,EACD;AAAA,EAEA,MAAM,KAAQ,MAAoC;AACjD,WAAO,IAAI,QAAoB,CAAC,SAAS,WAAW;AACnD,WAAK,MAAM,KAAK,MAAM,QAAQ,QAAQ,KAAK,CAAC,EAAE,KAAK,OAAO,EAAE,MAAM,MAAM,CAAC;AACzE,WAAK,IAAI;AAAA,IACV,CAAC;AAAA,EACF;AAAA,EAEA,QAAQ;AACP,SAAK,QAAQ,CAAC;AAAA,EACf;AACD;",
  "names": []
}
