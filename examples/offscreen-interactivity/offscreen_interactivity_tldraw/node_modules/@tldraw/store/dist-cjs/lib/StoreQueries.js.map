{
  "version": 3,
  "sources": ["../../src/lib/StoreQueries.ts"],
  "sourcesContent": ["import {\n\tAtom,\n\tcomputed,\n\tComputed,\n\tEMPTY_ARRAY,\n\tisUninitialized,\n\tRESET_VALUE,\n\twithDiff,\n} from '@tldraw/state'\nimport { areArraysShallowEqual, objectMapValues } from '@tldraw/utils'\nimport isEqual from 'lodash.isequal'\nimport { IdOf, UnknownRecord } from './BaseRecord'\nimport { executeQuery, objectMatchesQuery, QueryExpression } from './executeQuery'\nimport { IncrementalSetConstructor } from './IncrementalSetConstructor'\nimport { RecordsDiff } from './RecordsDiff'\nimport { diffSets } from './setUtils'\nimport { CollectionDiff } from './Store'\n\n/** @public */\nexport type RSIndexDiff<\n\tR extends UnknownRecord,\n\tProperty extends string & keyof R = string & keyof R,\n> = Map<R[Property], CollectionDiff<IdOf<R>>>\n\n/** @public */\nexport type RSIndexMap<\n\tR extends UnknownRecord,\n\tProperty extends string & keyof R = string & keyof R,\n> = Map<R[Property], Set<IdOf<R>>>\n\n/** @public */\nexport type RSIndex<\n\tR extends UnknownRecord,\n\tProperty extends string & keyof R = string & keyof R,\n> = Computed<RSIndexMap<R, Property>, RSIndexDiff<R, Property>>\n\n/**\n * A class that provides a 'namespace' for the various kinds of indexes one may wish to derive from\n * the record store.\n * @public\n */\nexport class StoreQueries<R extends UnknownRecord> {\n\tconstructor(\n\t\tprivate readonly atoms: Atom<Record<IdOf<R>, Atom<R>>>,\n\t\tprivate readonly history: Atom<number, RecordsDiff<R>>\n\t) {}\n\n\t/**\n\t * A cache of derivations (indexes).\n\t *\n\t * @internal\n\t */\n\tprivate indexCache = new Map<string, RSIndex<R>>()\n\n\t/**\n\t * A cache of derivations (filtered histories).\n\t *\n\t * @internal\n\t */\n\tprivate historyCache = new Map<string, Computed<number, RecordsDiff<R>>>()\n\n\t/**\n\t * Create a derivation that contains the history for a given type\n\t *\n\t * @param typeName - The name of the type to filter by.\n\t * @returns A derivation that returns the ids of all records of the given type.\n\t * @public\n\t */\n\tpublic filterHistory<TypeName extends R['typeName']>(\n\t\ttypeName: TypeName\n\t): Computed<number, RecordsDiff<Extract<R, { typeName: TypeName }>>> {\n\t\ttype S = Extract<R, { typeName: TypeName }>\n\n\t\tif (this.historyCache.has(typeName)) {\n\t\t\treturn this.historyCache.get(typeName) as any\n\t\t}\n\n\t\tconst filtered = computed<number, RecordsDiff<S>>(\n\t\t\t'filterHistory:' + typeName,\n\t\t\t(lastValue, lastComputedEpoch) => {\n\t\t\t\tif (isUninitialized(lastValue)) {\n\t\t\t\t\treturn this.history.get()\n\t\t\t\t}\n\n\t\t\t\tconst diff = this.history.getDiffSince(lastComputedEpoch)\n\t\t\t\tif (diff === RESET_VALUE) return this.history.get()\n\n\t\t\t\tconst res = { added: {}, removed: {}, updated: {} } as RecordsDiff<S>\n\t\t\t\tlet numAdded = 0\n\t\t\t\tlet numRemoved = 0\n\t\t\t\tlet numUpdated = 0\n\n\t\t\t\tfor (const changes of diff) {\n\t\t\t\t\tfor (const added of objectMapValues(changes.added)) {\n\t\t\t\t\t\tif (added.typeName === typeName) {\n\t\t\t\t\t\t\tif (res.removed[added.id as IdOf<S>]) {\n\t\t\t\t\t\t\t\tconst original = res.removed[added.id as IdOf<S>]\n\t\t\t\t\t\t\t\tdelete res.removed[added.id as IdOf<S>]\n\t\t\t\t\t\t\t\tnumRemoved--\n\t\t\t\t\t\t\t\tif (original !== added) {\n\t\t\t\t\t\t\t\t\tres.updated[added.id as IdOf<S>] = [original, added as S]\n\t\t\t\t\t\t\t\t\tnumUpdated++\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tres.added[added.id as IdOf<S>] = added as S\n\t\t\t\t\t\t\t\tnumAdded++\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (const [from, to] of objectMapValues(changes.updated)) {\n\t\t\t\t\t\tif (to.typeName === typeName) {\n\t\t\t\t\t\t\tif (res.added[to.id as IdOf<S>]) {\n\t\t\t\t\t\t\t\tres.added[to.id as IdOf<S>] = to as S\n\t\t\t\t\t\t\t} else if (res.updated[to.id as IdOf<S>]) {\n\t\t\t\t\t\t\t\tres.updated[to.id as IdOf<S>] = [res.updated[to.id as IdOf<S>][0], to as S]\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tres.updated[to.id as IdOf<S>] = [from as S, to as S]\n\t\t\t\t\t\t\t\tnumUpdated++\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (const removed of objectMapValues(changes.removed)) {\n\t\t\t\t\t\tif (removed.typeName === typeName) {\n\t\t\t\t\t\t\tif (res.added[removed.id as IdOf<S>]) {\n\t\t\t\t\t\t\t\t// was added during this diff sequence, so just undo the add\n\t\t\t\t\t\t\t\tdelete res.added[removed.id as IdOf<S>]\n\t\t\t\t\t\t\t\tnumAdded--\n\t\t\t\t\t\t\t} else if (res.updated[removed.id as IdOf<S>]) {\n\t\t\t\t\t\t\t\t// remove oldest version\n\t\t\t\t\t\t\t\tres.removed[removed.id as IdOf<S>] = res.updated[removed.id as IdOf<S>][0]\n\t\t\t\t\t\t\t\tdelete res.updated[removed.id as IdOf<S>]\n\t\t\t\t\t\t\t\tnumUpdated--\n\t\t\t\t\t\t\t\tnumRemoved++\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tres.removed[removed.id as IdOf<S>] = removed as S\n\t\t\t\t\t\t\t\tnumRemoved++\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (numAdded || numRemoved || numUpdated) {\n\t\t\t\t\treturn withDiff(this.history.get(), res)\n\t\t\t\t} else {\n\t\t\t\t\treturn lastValue\n\t\t\t\t}\n\t\t\t},\n\t\t\t{ historyLength: 100 }\n\t\t)\n\n\t\tthis.historyCache.set(typeName, filtered)\n\n\t\treturn filtered\n\t}\n\n\t/**\n\t * Create a derivation that returns an index on a property for the given type.\n\t *\n\t * @param typeName - The name of the type.\n\t * @param property - The name of the property.\n\t * @public\n\t */\n\tpublic index<\n\t\tTypeName extends R['typeName'],\n\t\tProperty extends string & keyof Extract<R, { typeName: TypeName }>,\n\t>(typeName: TypeName, property: Property): RSIndex<Extract<R, { typeName: TypeName }>, Property> {\n\t\tconst cacheKey = typeName + ':' + property\n\n\t\tif (this.indexCache.has(cacheKey)) {\n\t\t\treturn this.indexCache.get(cacheKey) as any\n\t\t}\n\n\t\tconst index = this.__uncached_createIndex(typeName, property)\n\n\t\tthis.indexCache.set(cacheKey, index as any)\n\n\t\treturn index\n\t}\n\n\t/**\n\t * Create a derivation that returns an index on a property for the given type.\n\t *\n\t * @param typeName - The name of the type?.\n\t * @param property - The name of the property?.\n\t * @internal\n\t */\n\t__uncached_createIndex<\n\t\tTypeName extends R['typeName'],\n\t\tProperty extends string & keyof Extract<R, { typeName: TypeName }>,\n\t>(typeName: TypeName, property: Property): RSIndex<Extract<R, { typeName: TypeName }>, Property> {\n\t\ttype S = Extract<R, { typeName: TypeName }>\n\n\t\tconst typeHistory = this.filterHistory(typeName)\n\n\t\tconst fromScratch = () => {\n\t\t\t// deref typeHistory early so that the first time the incremental version runs\n\t\t\t// it gets a diff to work with instead of having to bail to this from-scratch version\n\t\t\ttypeHistory.get()\n\t\t\tconst res = new Map<S[Property], Set<IdOf<S>>>()\n\t\t\tfor (const atom of objectMapValues(this.atoms.get())) {\n\t\t\t\tconst record = atom.get()\n\t\t\t\tif (record.typeName === typeName) {\n\t\t\t\t\tconst value = (record as S)[property]\n\t\t\t\t\tif (!res.has(value)) {\n\t\t\t\t\t\tres.set(value, new Set())\n\t\t\t\t\t}\n\t\t\t\t\tres.get(value)!.add(record.id)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn res\n\t\t}\n\n\t\treturn computed<RSIndexMap<S, Property>, RSIndexDiff<S, Property>>(\n\t\t\t'index:' + typeName + ':' + property,\n\t\t\t(prevValue, lastComputedEpoch) => {\n\t\t\t\tif (isUninitialized(prevValue)) return fromScratch()\n\n\t\t\t\tconst history = typeHistory.getDiffSince(lastComputedEpoch)\n\t\t\t\tif (history === RESET_VALUE) {\n\t\t\t\t\treturn fromScratch()\n\t\t\t\t}\n\n\t\t\t\tconst setConstructors = new Map<any, IncrementalSetConstructor<IdOf<S>>>()\n\n\t\t\t\tconst add = (value: S[Property], id: IdOf<S>) => {\n\t\t\t\t\tlet setConstructor = setConstructors.get(value)\n\t\t\t\t\tif (!setConstructor)\n\t\t\t\t\t\tsetConstructor = new IncrementalSetConstructor<IdOf<S>>(\n\t\t\t\t\t\t\tprevValue.get(value) ?? new Set()\n\t\t\t\t\t\t)\n\t\t\t\t\tsetConstructor.add(id)\n\t\t\t\t\tsetConstructors.set(value, setConstructor)\n\t\t\t\t}\n\n\t\t\t\tconst remove = (value: S[Property], id: IdOf<S>) => {\n\t\t\t\t\tlet set = setConstructors.get(value)\n\t\t\t\t\tif (!set) set = new IncrementalSetConstructor<IdOf<S>>(prevValue.get(value) ?? new Set())\n\t\t\t\t\tset.remove(id)\n\t\t\t\t\tsetConstructors.set(value, set)\n\t\t\t\t}\n\n\t\t\t\tfor (const changes of history) {\n\t\t\t\t\tfor (const record of objectMapValues(changes.added)) {\n\t\t\t\t\t\tif (record.typeName === typeName) {\n\t\t\t\t\t\t\tconst value = (record as S)[property]\n\t\t\t\t\t\t\tadd(value, record.id)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (const [from, to] of objectMapValues(changes.updated)) {\n\t\t\t\t\t\tif (to.typeName === typeName) {\n\t\t\t\t\t\t\tconst prev = (from as S)[property]\n\t\t\t\t\t\t\tconst next = (to as S)[property]\n\t\t\t\t\t\t\tif (prev !== next) {\n\t\t\t\t\t\t\t\tremove(prev, to.id)\n\t\t\t\t\t\t\t\tadd(next, to.id)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (const record of objectMapValues(changes.removed)) {\n\t\t\t\t\t\tif (record.typeName === typeName) {\n\t\t\t\t\t\t\tconst value = (record as S)[property]\n\t\t\t\t\t\t\tremove(value, record.id)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlet nextValue: undefined | RSIndexMap<S, Property> = undefined\n\t\t\t\tlet nextDiff: undefined | RSIndexDiff<S, Property> = undefined\n\n\t\t\t\tfor (const [value, setConstructor] of setConstructors) {\n\t\t\t\t\tconst result = setConstructor.get()\n\t\t\t\t\tif (!result) continue\n\t\t\t\t\tif (!nextValue) nextValue = new Map(prevValue)\n\t\t\t\t\tif (!nextDiff) nextDiff = new Map()\n\t\t\t\t\tif (result.value.size === 0) {\n\t\t\t\t\t\tnextValue.delete(value)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnextValue.set(value, result.value)\n\t\t\t\t\t}\n\t\t\t\t\tnextDiff.set(value, result.diff)\n\t\t\t\t}\n\n\t\t\t\tif (nextValue && nextDiff) {\n\t\t\t\t\treturn withDiff(nextValue, nextDiff)\n\t\t\t\t}\n\n\t\t\t\treturn prevValue\n\t\t\t},\n\t\t\t{ historyLength: 100 }\n\t\t)\n\t}\n\n\t/**\n\t * Create a derivation that will return a signle record matching the given query.\n\t *\n\t * It will return undefined if there is no matching record\n\t *\n\t * @param typeName - The name of the type?\n\t * @param queryCreator - A function that returns the query expression.\n\t * @param name - (optinal) The name of the query.\n\t */\n\trecord<TypeName extends R['typeName']>(\n\t\ttypeName: TypeName,\n\t\tqueryCreator: () => QueryExpression<Extract<R, { typeName: TypeName }>> = () => ({}),\n\t\tname = 'record:' + typeName + (queryCreator ? ':' + queryCreator.toString() : '')\n\t): Computed<Extract<R, { typeName: TypeName }> | undefined> {\n\t\ttype S = Extract<R, { typeName: TypeName }>\n\t\tconst ids = this.ids(typeName, queryCreator, name)\n\n\t\treturn computed<S | undefined>(name, () => {\n\t\t\tfor (const id of ids.get()) {\n\t\t\t\treturn this.atoms.get()[id]?.get() as S\n\t\t\t}\n\t\t\treturn undefined\n\t\t})\n\t}\n\n\t/**\n\t * Create a derivation that will return an array of records matching the given query\n\t *\n\t * @param typeName - The name of the type?\n\t * @param queryCreator - A function that returns the query expression.\n\t * @param name - (optinal) The name of the query.\n\t */\n\trecords<TypeName extends R['typeName']>(\n\t\ttypeName: TypeName,\n\t\tqueryCreator: () => QueryExpression<Extract<R, { typeName: TypeName }>> = () => ({}),\n\t\tname = 'records:' + typeName + (queryCreator ? ':' + queryCreator.toString() : '')\n\t): Computed<Array<Extract<R, { typeName: TypeName }>>> {\n\t\ttype S = Extract<R, { typeName: TypeName }>\n\t\tconst ids = this.ids(typeName, queryCreator, 'ids:' + name)\n\n\t\treturn computed<S[]>(\n\t\t\tname,\n\t\t\t() => {\n\t\t\t\tconst atoms = this.atoms.get()\n\t\t\t\treturn [...ids.get()].map((id) => {\n\t\t\t\t\tconst atom = atoms[id]\n\t\t\t\t\tif (!atom) {\n\t\t\t\t\t\tthrow new Error('no atom found for record id: ' + id)\n\t\t\t\t\t}\n\t\t\t\t\treturn atom.get() as S\n\t\t\t\t})\n\t\t\t},\n\t\t\t{\n\t\t\t\tisEqual: areArraysShallowEqual,\n\t\t\t}\n\t\t)\n\t}\n\n\t/**\n\t * Create a derivation that will return the ids of all records of the given type.\n\t *\n\t * @param typeName - The name of the type.\n\t * @param queryCreator - A function that returns the query expression.\n\t * @param name - (optinal) The name of the query.\n\t */\n\tids<TypeName extends R['typeName']>(\n\t\ttypeName: TypeName,\n\t\tqueryCreator: () => QueryExpression<Extract<R, { typeName: TypeName }>> = () => ({}),\n\t\tname = 'ids:' + typeName + (queryCreator ? ':' + queryCreator.toString() : '')\n\t): Computed<\n\t\tSet<IdOf<Extract<R, { typeName: TypeName }>>>,\n\t\tCollectionDiff<IdOf<Extract<R, { typeName: TypeName }>>>\n\t> {\n\t\ttype S = Extract<R, { typeName: TypeName }>\n\n\t\tconst typeHistory = this.filterHistory(typeName)\n\n\t\tconst fromScratch = () => {\n\t\t\t// deref type history early to allow first incremental update to use diffs\n\t\t\ttypeHistory.get()\n\t\t\tconst query: QueryExpression<S> = queryCreator()\n\t\t\tif (Object.keys(query).length === 0) {\n\t\t\t\treturn new Set<IdOf<S>>(\n\t\t\t\t\tobjectMapValues(this.atoms.get()).flatMap((v) => {\n\t\t\t\t\t\tconst r = v.get()\n\t\t\t\t\t\tif (r.typeName === typeName) {\n\t\t\t\t\t\t\treturn r.id\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn []\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t}\n\n\t\t\treturn executeQuery(this, typeName, query)\n\t\t}\n\n\t\tconst fromScratchWithDiff = (prevValue: Set<IdOf<S>>) => {\n\t\t\tconst nextValue = fromScratch()\n\t\t\tconst diff = diffSets(prevValue, nextValue)\n\t\t\tif (diff) {\n\t\t\t\treturn withDiff(nextValue, diff)\n\t\t\t} else {\n\t\t\t\treturn prevValue\n\t\t\t}\n\t\t}\n\t\tconst cachedQuery = computed('ids_query:' + name, queryCreator, {\n\t\t\tisEqual,\n\t\t})\n\n\t\treturn computed(\n\t\t\t'query:' + name,\n\t\t\t(prevValue, lastComputedEpoch) => {\n\t\t\t\tconst query = cachedQuery.get()\n\t\t\t\tif (isUninitialized(prevValue)) {\n\t\t\t\t\treturn fromScratch()\n\t\t\t\t}\n\n\t\t\t\t// if the query changed since last time this ran then we need to start again\n\t\t\t\tif (lastComputedEpoch < cachedQuery.lastChangedEpoch) {\n\t\t\t\t\treturn fromScratchWithDiff(prevValue)\n\t\t\t\t}\n\n\t\t\t\t// otherwise iterate over the changes from the store and apply them to the previous value if needed\n\t\t\t\tconst history = typeHistory.getDiffSince(lastComputedEpoch)\n\t\t\t\tif (history === RESET_VALUE) {\n\t\t\t\t\treturn fromScratchWithDiff(prevValue)\n\t\t\t\t}\n\n\t\t\t\tconst setConstructor = new IncrementalSetConstructor<IdOf<S>>(\n\t\t\t\t\tprevValue\n\t\t\t\t) as IncrementalSetConstructor<IdOf<S>>\n\n\t\t\t\tfor (const changes of history) {\n\t\t\t\t\tfor (const added of objectMapValues(changes.added)) {\n\t\t\t\t\t\tif (added.typeName === typeName && objectMatchesQuery(query, added)) {\n\t\t\t\t\t\t\tsetConstructor.add(added.id)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (const [_, updated] of objectMapValues(changes.updated)) {\n\t\t\t\t\t\tif (updated.typeName === typeName) {\n\t\t\t\t\t\t\tif (objectMatchesQuery(query, updated)) {\n\t\t\t\t\t\t\t\tsetConstructor.add(updated.id)\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tsetConstructor.remove(updated.id)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (const removed of objectMapValues(changes.removed)) {\n\t\t\t\t\t\tif (removed.typeName === typeName) {\n\t\t\t\t\t\t\tsetConstructor.remove(removed.id)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst result = setConstructor.get()\n\t\t\t\tif (!result) {\n\t\t\t\t\treturn prevValue\n\t\t\t\t}\n\n\t\t\t\treturn withDiff(result.value, result.diff)\n\t\t\t},\n\t\t\t{ historyLength: 50 }\n\t\t)\n\t}\n\n\texec<TypeName extends R['typeName']>(\n\t\ttypeName: TypeName,\n\t\tquery: QueryExpression<Extract<R, { typeName: TypeName }>>\n\t): Array<Extract<R, { typeName: TypeName }>> {\n\t\tconst ids = executeQuery(this, typeName, query)\n\t\tif (ids.size === 0) {\n\t\t\treturn EMPTY_ARRAY\n\t\t}\n\t\tconst atoms = this.atoms.get()\n\t\treturn [...ids].map((id) => atoms[id].get() as Extract<R, { typeName: TypeName }>)\n\t}\n}\n"],
  "mappings": "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",
  "names": ["isEqual"]
}
