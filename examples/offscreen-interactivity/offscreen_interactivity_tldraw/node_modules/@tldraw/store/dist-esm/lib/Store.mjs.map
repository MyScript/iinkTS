{
  "version": 3,
  "sources": ["../../src/lib/Store.ts"],
  "sourcesContent": ["import { Atom, Computed, Reactor, atom, computed, reactor, transact } from '@tldraw/state'\nimport {\n\tWeakCache,\n\tassert,\n\tfilterEntries,\n\tgetOwnProperty,\n\tobjectMapEntries,\n\tobjectMapFromEntries,\n\tobjectMapKeys,\n\tobjectMapValues,\n\tthrottleToNextFrame,\n\tuniqueId,\n} from '@tldraw/utils'\nimport { IdOf, RecordId, UnknownRecord } from './BaseRecord'\nimport { RecordScope } from './RecordType'\nimport { RecordsDiff, squashRecordDiffs } from './RecordsDiff'\nimport { StoreQueries } from './StoreQueries'\nimport { SerializedSchema, StoreSchema } from './StoreSchema'\nimport { StoreSideEffects } from './StoreSideEffects'\nimport { devFreeze } from './devFreeze'\n\n/** @public */\nexport type RecordFromId<K extends RecordId<UnknownRecord>> =\n\tK extends RecordId<infer R> ? R : never\n\n/**\n * A diff describing the changes to a collection.\n *\n * @public\n */\nexport interface CollectionDiff<T> {\n\tadded?: Set<T>\n\tremoved?: Set<T>\n}\n\n/** @public */\nexport type ChangeSource = 'user' | 'remote'\n\n/** @public */\nexport interface StoreListenerFilters {\n\tsource: ChangeSource | 'all'\n\tscope: RecordScope | 'all'\n}\n\n/**\n * An entry containing changes that originated either by user actions or remote changes.\n *\n * @public\n */\nexport interface HistoryEntry<R extends UnknownRecord = UnknownRecord> {\n\tchanges: RecordsDiff<R>\n\tsource: ChangeSource\n}\n\n/**\n * A function that will be called when the history changes.\n *\n * @public\n */\nexport type StoreListener<R extends UnknownRecord> = (entry: HistoryEntry<R>) => void\n\n/**\n * A record store is a collection of records of different types.\n *\n * @public\n */\nexport interface ComputedCache<Data, R extends UnknownRecord> {\n\tget(id: IdOf<R>): Data | undefined\n}\n\n/**\n * A serialized snapshot of the record store's values.\n *\n * @public\n */\nexport type SerializedStore<R extends UnknownRecord> = Record<IdOf<R>, R>\n\n/** @public */\nexport interface StoreSnapshot<R extends UnknownRecord> {\n\tstore: SerializedStore<R>\n\tschema: SerializedSchema\n}\n\n/** @public */\nexport interface StoreValidator<R extends UnknownRecord> {\n\tvalidate(record: unknown): R\n\tvalidateUsingKnownGoodVersion?(knownGoodVersion: R, record: unknown): R\n}\n\n/** @public */\nexport type StoreValidators<R extends UnknownRecord> = {\n\t[K in R['typeName']]: StoreValidator<Extract<R, { typeName: K }>>\n}\n\n/** @public */\nexport interface StoreError {\n\terror: Error\n\tphase: 'initialize' | 'createRecord' | 'updateRecord' | 'tests'\n\trecordBefore?: unknown\n\trecordAfter: unknown\n\tisExistingValidationIssue: boolean\n}\n\n/** @internal */\nexport type StoreRecord<S extends Store<any>> = S extends Store<infer R> ? R : never\n\n/**\n * A store of records.\n *\n * @public\n */\nexport class Store<R extends UnknownRecord = UnknownRecord, Props = unknown> {\n\t/**\n\t * The random id of the store.\n\t */\n\tpublic readonly id: string\n\t/**\n\t * An atom containing the store's atoms.\n\t *\n\t * @internal\n\t * @readonly\n\t */\n\tprivate readonly atoms = atom('store_atoms', {} as Record<IdOf<R>, Atom<R>>)\n\n\t/**\n\t * An atom containing the store's history.\n\t *\n\t * @public\n\t * @readonly\n\t */\n\treadonly history: Atom<number, RecordsDiff<R>> = atom('history', 0, {\n\t\thistoryLength: 1000,\n\t})\n\n\t/**\n\t * A StoreQueries instance for this store.\n\t *\n\t * @public\n\t * @readonly\n\t */\n\treadonly query = new StoreQueries<R>(this.atoms, this.history)\n\n\t/**\n\t * A set containing listeners that have been added to this store.\n\t *\n\t * @internal\n\t */\n\tprivate listeners = new Set<{ onHistory: StoreListener<R>; filters: StoreListenerFilters }>()\n\n\t/**\n\t * An array of history entries that have not yet been flushed.\n\t *\n\t * @internal\n\t */\n\tprivate historyAccumulator = new HistoryAccumulator<R>()\n\n\t/**\n\t * A reactor that responds to changes to the history by squashing the accumulated history and\n\t * notifying listeners of the changes.\n\t *\n\t * @internal\n\t */\n\tprivate historyReactor: Reactor\n\n\t/**\n\t * Function to dispose of any in-flight timeouts.\n\t *\n\t * @internal\n\t */\n\tprivate cancelHistoryReactor(): void {\n\t\t/* noop */\n\t}\n\n\treadonly schema: StoreSchema<R, Props>\n\n\treadonly props: Props\n\n\tpublic readonly scopedTypes: { readonly [K in RecordScope]: ReadonlySet<R['typeName']> }\n\n\tpublic readonly sideEffects = new StoreSideEffects<R>(this)\n\n\tconstructor(config: {\n\t\tid?: string\n\t\t/** The store's initial data. */\n\t\tinitialData?: SerializedStore<R>\n\t\t/**\n\t\t * A map of validators for each record type. A record's validator will be called when the record\n\t\t * is created or updated. It should throw an error if the record is invalid.\n\t\t */\n\t\tschema: StoreSchema<R, Props>\n\t\tprops: Props\n\t}) {\n\t\tconst { initialData, schema, id } = config\n\n\t\tthis.id = id ?? uniqueId()\n\t\tthis.schema = schema\n\t\tthis.props = config.props\n\n\t\tif (initialData) {\n\t\t\tthis.atoms.set(\n\t\t\t\tobjectMapFromEntries(\n\t\t\t\t\tobjectMapEntries(initialData).map(([id, record]) => [\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tatom(\n\t\t\t\t\t\t\t'atom:' + id,\n\t\t\t\t\t\t\tdevFreeze(this.schema.validateRecord(this, record, 'initialize', null))\n\t\t\t\t\t\t),\n\t\t\t\t\t])\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\n\t\tthis.historyReactor = reactor(\n\t\t\t'Store.historyReactor',\n\t\t\t() => {\n\t\t\t\t// deref to make sure we're subscribed regardless of whether we need to propagate\n\t\t\t\tthis.history.get()\n\t\t\t\t// If we have accumulated history, flush it and update listeners\n\t\t\t\tthis._flushHistory()\n\t\t\t},\n\t\t\t{ scheduleEffect: (cb) => (this.cancelHistoryReactor = throttleToNextFrame(cb)) }\n\t\t)\n\t\tthis.scopedTypes = {\n\t\t\tdocument: new Set(\n\t\t\t\tobjectMapValues(this.schema.types)\n\t\t\t\t\t.filter((t) => t.scope === 'document')\n\t\t\t\t\t.map((t) => t.typeName)\n\t\t\t),\n\t\t\tsession: new Set(\n\t\t\t\tobjectMapValues(this.schema.types)\n\t\t\t\t\t.filter((t) => t.scope === 'session')\n\t\t\t\t\t.map((t) => t.typeName)\n\t\t\t),\n\t\t\tpresence: new Set(\n\t\t\t\tobjectMapValues(this.schema.types)\n\t\t\t\t\t.filter((t) => t.scope === 'presence')\n\t\t\t\t\t.map((t) => t.typeName)\n\t\t\t),\n\t\t}\n\t}\n\n\tpublic _flushHistory() {\n\t\t// If we have accumulated history, flush it and update listeners\n\t\tif (this.historyAccumulator.hasChanges()) {\n\t\t\tconst entries = this.historyAccumulator.flush()\n\t\t\tfor (const { changes, source } of entries) {\n\t\t\t\tlet instanceChanges = null as null | RecordsDiff<R>\n\t\t\t\tlet documentChanges = null as null | RecordsDiff<R>\n\t\t\t\tlet presenceChanges = null as null | RecordsDiff<R>\n\t\t\t\tfor (const { onHistory, filters } of this.listeners) {\n\t\t\t\t\tif (filters.source !== 'all' && filters.source !== source) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif (filters.scope !== 'all') {\n\t\t\t\t\t\tif (filters.scope === 'document') {\n\t\t\t\t\t\t\tdocumentChanges ??= this.filterChangesByScope(changes, 'document')\n\t\t\t\t\t\t\tif (!documentChanges) continue\n\t\t\t\t\t\t\tonHistory({ changes: documentChanges, source })\n\t\t\t\t\t\t} else if (filters.scope === 'session') {\n\t\t\t\t\t\t\tinstanceChanges ??= this.filterChangesByScope(changes, 'session')\n\t\t\t\t\t\t\tif (!instanceChanges) continue\n\t\t\t\t\t\t\tonHistory({ changes: instanceChanges, source })\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpresenceChanges ??= this.filterChangesByScope(changes, 'presence')\n\t\t\t\t\t\t\tif (!presenceChanges) continue\n\t\t\t\t\t\t\tonHistory({ changes: presenceChanges, source })\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tonHistory({ changes, source })\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdispose() {\n\t\tthis.cancelHistoryReactor()\n\t}\n\n\t/**\n\t * Filters out non-document changes from a diff. Returns null if there are no changes left.\n\t * @param change - the records diff\n\t * @param scope - the records scope\n\t * @returns\n\t */\n\tfilterChangesByScope(change: RecordsDiff<R>, scope: RecordScope) {\n\t\tconst result = {\n\t\t\tadded: filterEntries(change.added, (_, r) => this.scopedTypes[scope].has(r.typeName)),\n\t\t\tupdated: filterEntries(change.updated, (_, r) => this.scopedTypes[scope].has(r[1].typeName)),\n\t\t\tremoved: filterEntries(change.removed, (_, r) => this.scopedTypes[scope].has(r.typeName)),\n\t\t}\n\t\tif (\n\t\t\tObject.keys(result.added).length === 0 &&\n\t\t\tObject.keys(result.updated).length === 0 &&\n\t\t\tObject.keys(result.removed).length === 0\n\t\t) {\n\t\t\treturn null\n\t\t}\n\t\treturn result\n\t}\n\n\t/**\n\t * Update the history with a diff of changes.\n\t *\n\t * @param changes - The changes to add to the history.\n\t */\n\tprivate updateHistory(changes: RecordsDiff<R>): void {\n\t\tthis.historyAccumulator.add({\n\t\t\tchanges,\n\t\t\tsource: this.isMergingRemoteChanges ? 'remote' : 'user',\n\t\t})\n\t\tif (this.listeners.size === 0) {\n\t\t\tthis.historyAccumulator.clear()\n\t\t}\n\t\tthis.history.set(this.history.get() + 1, changes)\n\t}\n\n\tvalidate(phase: 'initialize' | 'createRecord' | 'updateRecord' | 'tests') {\n\t\tthis.allRecords().forEach((record) => this.schema.validateRecord(this, record, phase, null))\n\t}\n\n\t/**\n\t * Add some records to the store. It's an error if they already exist.\n\t *\n\t * @param records - The records to add.\n\t * @param phaseOverride - The phase override.\n\t * @public\n\t */\n\tput(records: R[], phaseOverride?: 'initialize'): void {\n\t\tthis.atomic(() => {\n\t\t\tconst updates: Record<IdOf<UnknownRecord>, [from: R, to: R]> = {}\n\t\t\tconst additions: Record<IdOf<UnknownRecord>, R> = {}\n\n\t\t\tconst currentMap = this.atoms.__unsafe__getWithoutCapture()\n\t\t\tlet map = null as null | Record<IdOf<UnknownRecord>, Atom<R>>\n\n\t\t\t// Iterate through all records, creating, updating or removing as needed\n\t\t\tlet record: R\n\n\t\t\t// There's a chance that, despite having records, all of the values are\n\t\t\t// identical to what they were before; and so we'd end up with an \"empty\"\n\t\t\t// history entry. Let's keep track of whether we've actually made any\n\t\t\t// changes (e.g. additions, deletions, or updates that produce a new value).\n\t\t\tlet didChange = false\n\n\t\t\tconst source = this.isMergingRemoteChanges ? 'remote' : 'user'\n\n\t\t\tfor (let i = 0, n = records.length; i < n; i++) {\n\t\t\t\trecord = records[i]\n\n\t\t\t\tconst recordAtom = (map ?? currentMap)[record.id as IdOf<R>]\n\n\t\t\t\tif (recordAtom) {\n\t\t\t\t\t// If we already have an atom for this record, update its value.\n\t\t\t\t\tconst initialValue = recordAtom.__unsafe__getWithoutCapture()\n\n\t\t\t\t\t// If we have a beforeUpdate callback, run it against the initial and next records\n\t\t\t\t\trecord = this.sideEffects.handleBeforeChange(initialValue, record, source)\n\n\t\t\t\t\t// Validate the record\n\t\t\t\t\tconst validated = this.schema.validateRecord(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\trecord,\n\t\t\t\t\t\tphaseOverride ?? 'updateRecord',\n\t\t\t\t\t\tinitialValue\n\t\t\t\t\t)\n\n\t\t\t\t\tif (validated === initialValue) continue\n\n\t\t\t\t\trecordAtom.set(devFreeze(record))\n\n\t\t\t\t\tdidChange = true\n\t\t\t\t\tconst updated = recordAtom.__unsafe__getWithoutCapture()\n\t\t\t\t\tupdates[record.id] = [initialValue, updated]\n\t\t\t\t\tthis.addDiffForAfterEvent(initialValue, updated)\n\t\t\t\t} else {\n\t\t\t\t\trecord = this.sideEffects.handleBeforeCreate(record, source)\n\n\t\t\t\t\tdidChange = true\n\n\t\t\t\t\t// If we don't have an atom, create one.\n\n\t\t\t\t\t// Validate the record\n\t\t\t\t\trecord = this.schema.validateRecord(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\trecord as R,\n\t\t\t\t\t\tphaseOverride ?? 'createRecord',\n\t\t\t\t\t\tnull\n\t\t\t\t\t)\n\n\t\t\t\t\t// Mark the change as a new addition.\n\t\t\t\t\tadditions[record.id] = record\n\t\t\t\t\tthis.addDiffForAfterEvent(null, record)\n\n\t\t\t\t\t// Assign the atom to the map under the record's id.\n\t\t\t\t\tif (!map) {\n\t\t\t\t\t\tmap = { ...currentMap }\n\t\t\t\t\t}\n\t\t\t\t\tmap[record.id] = atom('atom:' + record.id, record)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set the map of atoms to the store.\n\t\t\tif (map) {\n\t\t\t\tthis.atoms.set(map)\n\t\t\t}\n\n\t\t\t// If we did change, update the history\n\t\t\tif (!didChange) return\n\t\t\tthis.updateHistory({\n\t\t\t\tadded: additions,\n\t\t\t\tupdated: updates,\n\t\t\t\tremoved: {} as Record<IdOf<R>, R>,\n\t\t\t})\n\t\t})\n\t}\n\n\t/**\n\t * Remove some records from the store via their ids.\n\t *\n\t * @param ids - The ids of the records to remove.\n\t * @public\n\t */\n\tremove(ids: IdOf<R>[]): void {\n\t\tthis.atomic(() => {\n\t\t\tconst cancelled = new Set<IdOf<R>>()\n\t\t\tconst source = this.isMergingRemoteChanges ? 'remote' : 'user'\n\n\t\t\tif (this.sideEffects.isEnabled()) {\n\t\t\t\tfor (const id of ids) {\n\t\t\t\t\tconst atom = this.atoms.__unsafe__getWithoutCapture()[id]\n\t\t\t\t\tif (!atom) continue\n\n\t\t\t\t\tif (this.sideEffects.handleBeforeDelete(atom.get(), source) === false) {\n\t\t\t\t\t\tcancelled.add(id)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet removed = undefined as undefined | RecordsDiff<R>['removed']\n\n\t\t\t// For each map in our atoms, remove the ids that we are removing.\n\t\t\tthis.atoms.update((atoms) => {\n\t\t\t\tlet result: typeof atoms | undefined = undefined\n\n\t\t\t\tfor (const id of ids) {\n\t\t\t\t\tif (cancelled.has(id)) continue\n\t\t\t\t\tif (!(id in atoms)) continue\n\t\t\t\t\tif (!result) result = { ...atoms }\n\t\t\t\t\tif (!removed) removed = {} as Record<IdOf<R>, R>\n\t\t\t\t\tdelete result[id]\n\t\t\t\t\tconst record = atoms[id].get()\n\t\t\t\t\tremoved[id] = record\n\t\t\t\t\tthis.addDiffForAfterEvent(record, null)\n\t\t\t\t}\n\n\t\t\t\treturn result ?? atoms\n\t\t\t})\n\n\t\t\tif (!removed) return\n\t\t\t// Update the history with the removed records.\n\t\t\tthis.updateHistory({ added: {}, updated: {}, removed } as RecordsDiff<R>)\n\t\t})\n\t}\n\n\t/**\n\t * Get the value of a store record by its id.\n\t *\n\t * @param id - The id of the record to get.\n\t * @public\n\t */\n\tget<K extends IdOf<R>>(id: K): RecordFromId<K> | undefined {\n\t\treturn this.atoms.get()[id]?.get() as any\n\t}\n\n\t/**\n\t * Get the value of a store record by its id without updating its epoch.\n\t *\n\t * @param id - The id of the record to get.\n\t * @public\n\t */\n\tunsafeGetWithoutCapture<K extends IdOf<R>>(id: K): RecordFromId<K> | undefined {\n\t\treturn this.atoms.__unsafe__getWithoutCapture()[id]?.__unsafe__getWithoutCapture() as any\n\t}\n\n\t/**\n\t * Creates a JSON payload from the record store.\n\t *\n\t * @param scope - The scope of records to serialize. Defaults to 'document'.\n\t * @returns The record store snapshot as a JSON payload.\n\t */\n\tserialize(scope: RecordScope | 'all' = 'document'): SerializedStore<R> {\n\t\tconst result = {} as SerializedStore<R>\n\t\tfor (const [id, atom] of objectMapEntries(this.atoms.get())) {\n\t\t\tconst record = atom.get()\n\t\t\tif (scope === 'all' || this.scopedTypes[scope].has(record.typeName)) {\n\t\t\t\tresult[id as IdOf<R>] = record\n\t\t\t}\n\t\t}\n\t\treturn result\n\t}\n\n\t/**\n\t * Get a serialized snapshot of the store and its schema.\n\t *\n\t * ```ts\n\t * const snapshot = store.getStoreSnapshot()\n\t * store.loadStoreSnapshot(snapshot)\n\t * ```\n\t *\n\t * @param scope - The scope of records to serialize. Defaults to 'document'.\n\t *\n\t * @public\n\t */\n\tgetStoreSnapshot(scope: RecordScope | 'all' = 'document'): StoreSnapshot<R> {\n\t\treturn {\n\t\t\tstore: this.serialize(scope),\n\t\t\tschema: this.schema.serialize(),\n\t\t}\n\t}\n\n\t/**\n\t * @deprecated use `getSnapshot` from the 'tldraw' package instead.\n\t */\n\tgetSnapshot(scope: RecordScope | 'all' = 'document') {\n\t\tconsole.warn(\n\t\t\t'[tldraw] `Store.getSnapshot` is deprecated and will be removed in a future release. Use `getSnapshot` from the `tldraw` package instead.'\n\t\t)\n\t\treturn this.getStoreSnapshot(scope)\n\t}\n\n\t/**\n\t * Migrate a serialized snapshot of the store and its schema.\n\t *\n\t * ```ts\n\t * const snapshot = store.getSnapshot()\n\t * store.migrateSnapshot(snapshot)\n\t * ```\n\t *\n\t * @param snapshot - The snapshot to load.\n\t * @public\n\t */\n\tmigrateSnapshot(snapshot: StoreSnapshot<R>): StoreSnapshot<R> {\n\t\tconst migrationResult = this.schema.migrateStoreSnapshot(snapshot)\n\n\t\tif (migrationResult.type === 'error') {\n\t\t\tthrow new Error(`Failed to migrate snapshot: ${migrationResult.reason}`)\n\t\t}\n\n\t\treturn {\n\t\t\tstore: migrationResult.value,\n\t\t\tschema: this.schema.serialize(),\n\t\t}\n\t}\n\n\t/**\n\t * Load a serialized snapshot.\n\t *\n\t * ```ts\n\t * const snapshot = store.getStoreSnapshot()\n\t * store.loadStoreSnapshot(snapshot)\n\t * ```\n\t *\n\t * @param snapshot - The snapshot to load.\n\t * @public\n\t */\n\tloadStoreSnapshot(snapshot: StoreSnapshot<R>): void {\n\t\tconst migrationResult = this.schema.migrateStoreSnapshot(snapshot)\n\n\t\tif (migrationResult.type === 'error') {\n\t\t\tthrow new Error(`Failed to migrate snapshot: ${migrationResult.reason}`)\n\t\t}\n\n\t\tconst prevSideEffectsEnabled = this.sideEffects.isEnabled()\n\t\ttry {\n\t\t\tthis.sideEffects.setIsEnabled(false)\n\t\t\tthis.atomic(() => {\n\t\t\t\tthis.clear()\n\t\t\t\tthis.put(Object.values(migrationResult.value))\n\t\t\t\tthis.ensureStoreIsUsable()\n\t\t\t})\n\t\t} finally {\n\t\t\tthis.sideEffects.setIsEnabled(prevSideEffectsEnabled)\n\t\t}\n\t}\n\n\t/**\n\t * @public\n\t * @deprecated use `loadSnapshot` from the 'tldraw' package instead.\n\t */\n\tloadSnapshot(snapshot: StoreSnapshot<R>) {\n\t\tconsole.warn(\n\t\t\t\"[tldraw] `Store.loadSnapshot` is deprecated and will be removed in a future release. Use `loadSnapshot` from the 'tldraw' package instead.\"\n\t\t)\n\t\tthis.loadStoreSnapshot(snapshot)\n\t}\n\n\t/**\n\t * Get an array of all values in the store.\n\t *\n\t * @returns An array of all values in the store.\n\t * @public\n\t */\n\tallRecords(): R[] {\n\t\treturn objectMapValues(this.atoms.get()).map((atom) => atom.get())\n\t}\n\n\t/**\n\t * Removes all records from the store.\n\t *\n\t * @public\n\t */\n\tclear(): void {\n\t\tthis.remove(objectMapKeys(this.atoms.get()))\n\t}\n\n\t/**\n\t * Update a record. To update multiple records at once, use the `update` method of the\n\t * `TypedStore` class.\n\t *\n\t * @param id - The id of the record to update.\n\t * @param updater - A function that updates the record.\n\t */\n\tupdate<K extends IdOf<R>>(id: K, updater: (record: RecordFromId<K>) => RecordFromId<K>) {\n\t\tconst atom = this.atoms.get()[id]\n\t\tif (!atom) {\n\t\t\tconsole.error(`Record ${id} not found. This is probably an error`)\n\t\t\treturn\n\t\t}\n\n\t\tthis.put([updater(atom.__unsafe__getWithoutCapture() as any as RecordFromId<K>) as any])\n\t}\n\n\t/**\n\t * Get whether the record store has a id.\n\t *\n\t * @param id - The id of the record to check.\n\t * @public\n\t */\n\thas<K extends IdOf<R>>(id: K): boolean {\n\t\treturn !!this.atoms.get()[id]\n\t}\n\n\t/**\n\t * Add a new listener to the store.\n\t *\n\t * @param onHistory - The listener to call when the store updates.\n\t * @param filters - Filters to apply to the listener.\n\t * @returns A function to remove the listener.\n\t */\n\tlisten(onHistory: StoreListener<R>, filters?: Partial<StoreListenerFilters>) {\n\t\t// flush history so that this listener's history starts from exactly now\n\t\tthis._flushHistory()\n\n\t\tconst listener = {\n\t\t\tonHistory,\n\t\t\tfilters: {\n\t\t\t\tsource: filters?.source ?? 'all',\n\t\t\t\tscope: filters?.scope ?? 'all',\n\t\t\t},\n\t\t}\n\n\t\tif (!this.historyReactor.scheduler.isActivelyListening) {\n\t\t\tthis.historyReactor.start()\n\t\t\tthis.historyReactor.scheduler.execute()\n\t\t}\n\n\t\tthis.listeners.add(listener)\n\n\t\treturn () => {\n\t\t\tthis.listeners.delete(listener)\n\n\t\t\tif (this.listeners.size === 0) {\n\t\t\t\tthis.historyReactor.stop()\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate isMergingRemoteChanges = false\n\n\t/**\n\t * Merge changes from a remote source without triggering listeners.\n\t *\n\t * @param fn - A function that merges the external changes.\n\t * @public\n\t */\n\tmergeRemoteChanges(fn: () => void) {\n\t\tif (this.isMergingRemoteChanges) {\n\t\t\treturn fn()\n\t\t}\n\n\t\tif (this._isInAtomicOp) {\n\t\t\tthrow new Error('Cannot merge remote changes while in atomic operation')\n\t\t}\n\n\t\ttry {\n\t\t\tthis.isMergingRemoteChanges = true\n\t\t\ttransact(fn)\n\t\t} finally {\n\t\t\tthis.isMergingRemoteChanges = false\n\t\t\tthis.ensureStoreIsUsable()\n\t\t}\n\t}\n\n\t/**\n\t * Run `fn` and return a {@link RecordsDiff} of the changes that occurred as a result.\n\t */\n\textractingChanges(fn: () => void): RecordsDiff<R> {\n\t\tconst changes: Array<RecordsDiff<R>> = []\n\t\tconst dispose = this.historyAccumulator.addInterceptor((entry) => changes.push(entry.changes))\n\t\ttry {\n\t\t\ttransact(fn)\n\t\t\treturn squashRecordDiffs(changes)\n\t\t} finally {\n\t\t\tdispose()\n\t\t}\n\t}\n\n\tapplyDiff(\n\t\tdiff: RecordsDiff<R>,\n\t\t{\n\t\t\trunCallbacks = true,\n\t\t\tignoreEphemeralKeys = false,\n\t\t}: { runCallbacks?: boolean; ignoreEphemeralKeys?: boolean } = {}\n\t) {\n\t\tthis.atomic(() => {\n\t\t\tconst toPut = objectMapValues(diff.added)\n\n\t\t\tfor (const [_from, to] of objectMapValues(diff.updated)) {\n\t\t\t\tconst type = this.schema.getType(to.typeName)\n\t\t\t\tif (ignoreEphemeralKeys && type.ephemeralKeySet.size) {\n\t\t\t\t\tconst existing = this.get(to.id)\n\t\t\t\t\tif (!existing) {\n\t\t\t\t\t\ttoPut.push(to)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tlet changed: R | null = null\n\t\t\t\t\tfor (const [key, value] of Object.entries(to)) {\n\t\t\t\t\t\tif (type.ephemeralKeySet.has(key) || Object.is(value, getOwnProperty(existing, key))) {\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!changed) changed = { ...existing } as R\n\t\t\t\t\t\t;(changed as any)[key] = value\n\t\t\t\t\t}\n\t\t\t\t\tif (changed) toPut.push(changed)\n\t\t\t\t} else {\n\t\t\t\t\ttoPut.push(to)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst toRemove = objectMapKeys(diff.removed)\n\t\t\tif (toPut.length) {\n\t\t\t\tthis.put(toPut)\n\t\t\t}\n\t\t\tif (toRemove.length) {\n\t\t\t\tthis.remove(toRemove)\n\t\t\t}\n\t\t}, runCallbacks)\n\t}\n\n\t/**\n\t * Create a computed cache.\n\t *\n\t * @param name - The name of the derivation cache.\n\t * @param derive - A function used to derive the value of the cache.\n\t * @param isEqual - A function that determines equality between two records.\n\t * @public\n\t */\n\tcreateComputedCache<Result, Record extends R = R>(\n\t\tname: string,\n\t\tderive: (record: Record) => Result | undefined,\n\t\tisEqual?: (a: Record, b: Record) => boolean\n\t): ComputedCache<Result, Record> {\n\t\tconst cache = new WeakCache<Atom<any>, Computed<Result | undefined>>()\n\t\treturn {\n\t\t\tget: (id: IdOf<Record>) => {\n\t\t\t\tconst atom = this.atoms.get()[id]\n\t\t\t\tif (!atom) {\n\t\t\t\t\treturn undefined\n\t\t\t\t}\n\t\t\t\treturn cache\n\t\t\t\t\t.get(atom, () => {\n\t\t\t\t\t\tconst recordSignal = isEqual\n\t\t\t\t\t\t\t? computed(atom.name + ':equals', () => atom.get(), { isEqual })\n\t\t\t\t\t\t\t: atom\n\t\t\t\t\t\treturn computed<Result | undefined>(name + ':' + id, () => {\n\t\t\t\t\t\t\treturn derive(recordSignal.get() as Record)\n\t\t\t\t\t\t})\n\t\t\t\t\t})\n\t\t\t\t\t.get()\n\t\t\t},\n\t\t}\n\t}\n\n\t/**\n\t * Create a computed cache from a selector\n\t *\n\t * @param name - The name of the derivation cache.\n\t * @param selector - A function that returns a subset of the original shape\n\t * @param derive - A function used to derive the value of the cache.\n\t * @public\n\t */\n\tcreateSelectedComputedCache<Selection, Result, Record extends R = R>(\n\t\tname: string,\n\t\tselector: (record: Record) => Selection | undefined,\n\t\tderive: (input: Selection) => Result | undefined\n\t): ComputedCache<Result, Record> {\n\t\tconst cache = new WeakCache<Atom<any>, Computed<Result | undefined>>()\n\t\treturn {\n\t\t\tget: (id: IdOf<Record>) => {\n\t\t\t\tconst atom = this.atoms.get()[id]\n\t\t\t\tif (!atom) {\n\t\t\t\t\treturn undefined\n\t\t\t\t}\n\n\t\t\t\treturn cache\n\t\t\t\t\t.get(atom, () => {\n\t\t\t\t\t\tconst d = computed<Selection | undefined>(name + ':' + id + ':selector', () =>\n\t\t\t\t\t\t\tselector(atom.get() as Record)\n\t\t\t\t\t\t)\n\t\t\t\t\t\treturn computed<Result | undefined>(name + ':' + id, () => derive(d.get() as Selection))\n\t\t\t\t\t})\n\t\t\t\t\t.get()\n\t\t\t},\n\t\t}\n\t}\n\n\tprivate _integrityChecker?: () => void | undefined\n\n\t/** @internal */\n\tensureStoreIsUsable() {\n\t\tthis.atomic(() => {\n\t\t\tthis._integrityChecker ??= this.schema.createIntegrityChecker(this)\n\t\t\tthis._integrityChecker?.()\n\t\t})\n\t}\n\n\tprivate _isPossiblyCorrupted = false\n\t/** @internal */\n\tmarkAsPossiblyCorrupted() {\n\t\tthis._isPossiblyCorrupted = true\n\t}\n\t/** @internal */\n\tisPossiblyCorrupted() {\n\t\treturn this._isPossiblyCorrupted\n\t}\n\n\tprivate pendingAfterEvents: Map<IdOf<R>, { before: R | null; after: R | null }> | null = null\n\tprivate addDiffForAfterEvent(before: R | null, after: R | null) {\n\t\tassert(this.pendingAfterEvents, 'must be in event operation')\n\t\tif (before === after) return\n\t\tif (before && after) assert(before.id === after.id)\n\t\tif (!before && !after) return\n\t\tconst id = (before || after)!.id\n\t\tconst existing = this.pendingAfterEvents.get(id)\n\t\tif (existing) {\n\t\t\texisting.after = after\n\t\t} else {\n\t\t\tthis.pendingAfterEvents.set(id, { before, after })\n\t\t}\n\t}\n\tprivate flushAtomicCallbacks() {\n\t\tlet updateDepth = 0\n\t\tconst source = this.isMergingRemoteChanges ? 'remote' : 'user'\n\t\twhile (this.pendingAfterEvents) {\n\t\t\tconst events = this.pendingAfterEvents\n\t\t\tthis.pendingAfterEvents = null\n\n\t\t\tif (!this.sideEffects.isEnabled()) continue\n\n\t\t\tupdateDepth++\n\t\t\tif (updateDepth > 100) {\n\t\t\t\tthrow new Error('Maximum store update depth exceeded, bailing out')\n\t\t\t}\n\n\t\t\tfor (const { before, after } of events.values()) {\n\t\t\t\tif (before && after) {\n\t\t\t\t\tthis.sideEffects.handleAfterChange(before, after, source)\n\t\t\t\t} else if (before && !after) {\n\t\t\t\t\tthis.sideEffects.handleAfterDelete(before, source)\n\t\t\t\t} else if (!before && after) {\n\t\t\t\t\tthis.sideEffects.handleAfterCreate(after, source)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!this.pendingAfterEvents) {\n\t\t\t\tthis.sideEffects.handleOperationComplete(source)\n\t\t\t}\n\t\t}\n\t}\n\tprivate _isInAtomicOp = false\n\t/** @internal */\n\tatomic<T>(fn: () => T, runCallbacks = true): T {\n\t\treturn transact(() => {\n\t\t\tif (this._isInAtomicOp) {\n\t\t\t\tif (!this.pendingAfterEvents) this.pendingAfterEvents = new Map()\n\t\t\t\treturn fn()\n\t\t\t}\n\n\t\t\tthis.pendingAfterEvents = new Map()\n\t\t\tconst prevSideEffectsEnabled = this.sideEffects.isEnabled()\n\t\t\tthis.sideEffects.setIsEnabled(runCallbacks ?? prevSideEffectsEnabled)\n\t\t\tthis._isInAtomicOp = true\n\t\t\ttry {\n\t\t\t\tconst result = fn()\n\n\t\t\t\tthis.flushAtomicCallbacks()\n\n\t\t\t\treturn result\n\t\t\t} finally {\n\t\t\t\tthis.pendingAfterEvents = null\n\t\t\t\tthis.sideEffects.setIsEnabled(prevSideEffectsEnabled)\n\t\t\t\tthis._isInAtomicOp = false\n\t\t\t}\n\t\t})\n\t}\n\n\t/** @internal */\n\taddHistoryInterceptor(fn: (entry: HistoryEntry<R>, source: ChangeSource) => void) {\n\t\treturn this.historyAccumulator.addInterceptor((entry) =>\n\t\t\tfn(entry, this.isMergingRemoteChanges ? 'remote' : 'user')\n\t\t)\n\t}\n}\n\n/**\n * Collect all history entries by their adjacent sources.\n * For example, [user, user, remote, remote, user] would result in [user, remote, user],\n * with adjacent entries of the same source squashed into a single entry.\n *\n * @param entries - The array of history entries.\n * @returns A map of history entries by their sources.\n * @public\n */\nfunction squashHistoryEntries<T extends UnknownRecord>(\n\tentries: HistoryEntry<T>[]\n): HistoryEntry<T>[] {\n\tif (entries.length === 0) return []\n\n\tconst chunked: HistoryEntry<T>[][] = []\n\tlet chunk: HistoryEntry<T>[] = [entries[0]]\n\tlet entry: HistoryEntry<T>\n\n\tfor (let i = 1, n = entries.length; i < n; i++) {\n\t\tentry = entries[i]\n\t\tif (chunk[0].source !== entry.source) {\n\t\t\tchunked.push(chunk)\n\t\t\tchunk = []\n\t\t}\n\t\tchunk.push(entry)\n\t}\n\t// Push the last chunk\n\tchunked.push(chunk)\n\n\treturn devFreeze(\n\t\tchunked.map((chunk) => ({\n\t\t\tsource: chunk[0].source,\n\t\t\tchanges: squashRecordDiffs(chunk.map((e) => e.changes)),\n\t\t}))\n\t)\n}\n\nclass HistoryAccumulator<T extends UnknownRecord> {\n\tprivate _history: HistoryEntry<T>[] = []\n\n\tprivate _interceptors: Set<(entry: HistoryEntry<T>) => void> = new Set()\n\n\taddInterceptor(fn: (entry: HistoryEntry<T>) => void) {\n\t\tthis._interceptors.add(fn)\n\t\treturn () => {\n\t\t\tthis._interceptors.delete(fn)\n\t\t}\n\t}\n\n\tadd(entry: HistoryEntry<T>) {\n\t\tthis._history.push(entry)\n\t\tfor (const interceptor of this._interceptors) {\n\t\t\tinterceptor(entry)\n\t\t}\n\t}\n\n\tflush() {\n\t\tconst history = squashHistoryEntries(this._history)\n\t\tthis._history = []\n\t\treturn history\n\t}\n\n\tclear() {\n\t\tthis._history = []\n\t}\n\n\thasChanges() {\n\t\treturn this._history.length > 0\n\t}\n}\n\n/** @public */\nexport type StoreObject<R extends UnknownRecord> = Store<R> | { store: Store<R> }\n/** @public */\nexport type StoreObjectRecordType<Context extends StoreObject<any>> =\n\tContext extends Store<infer R> ? R : Context extends { store: Store<infer R> } ? R : never\n\n/**\n * Free version of {@link Store.createComputedCache}.\n *\n * @example\n * ```ts\n * const myCache = createComputedCache('myCache', (editor: Editor, shape: TLShape) => {\n *     return editor.getSomethingExpensive(shape)\n * })\n *\n * myCache.get(editor, shape.id)\n * ```\n *\n * @public\n */\nexport function createComputedCache<\n\tContext extends StoreObject<any>,\n\tResult,\n\tRecord extends StoreObjectRecordType<Context> = StoreObjectRecordType<Context>,\n>(\n\tname: string,\n\tderive: (context: Context, record: Record) => Result | undefined,\n\tisEqual?: (a: Record, b: Record) => boolean\n) {\n\tconst cache = new WeakCache<Context, ComputedCache<Result, Record>>()\n\treturn {\n\t\tget(context: Context, id: IdOf<Record>) {\n\t\t\tconst computedCache = cache.get(context, () => {\n\t\t\t\tconst store = (context instanceof Store ? context : context.store) as Store<Record>\n\t\t\t\treturn store.createComputedCache(name, (record) => derive(context, record), isEqual)\n\t\t\t})\n\t\t\treturn computedCache.get(id)\n\t\t},\n\t}\n}\n"],
  "mappings": "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",
  "names": ["id", "atom", "chunk"]
}
