{
  "version": 3,
  "sources": ["../../../../src/lib/shapes/arrow/curved-arrow.ts"],
  "sourcesContent": ["import {\n\tEditor,\n\tMat,\n\tPI,\n\tPI2,\n\tTLArrowShape,\n\tVec,\n\tVecLike,\n\tcenterOfCircleFromThreePoints,\n\tclockwiseAngleDist,\n\tcounterClockwiseAngleDist,\n\tintersectCirclePolygon,\n\tintersectCirclePolyline,\n\tisSafeFloat,\n} from '@tldraw/editor'\nimport { TLArcInfo, TLArrowInfo } from './arrow-types'\nimport {\n\tBOUND_ARROW_OFFSET,\n\tMIN_ARROW_LENGTH,\n\tSTROKE_SIZES,\n\tTLArrowBindings,\n\tWAY_TOO_BIG_ARROW_BEND_FACTOR,\n\tgetArrowTerminalsInArrowSpace,\n\tgetBoundShapeInfoForTerminal,\n\tgetBoundShapeRelationships,\n} from './shared'\nimport { getStraightArrowInfo } from './straight-arrow'\n\nexport function getCurvedArrowInfo(\n\teditor: Editor,\n\tshape: TLArrowShape,\n\tbindings: TLArrowBindings\n): TLArrowInfo {\n\tconst { arrowheadEnd, arrowheadStart } = shape.props\n\tconst bend = shape.props.bend\n\n\tif (\n\t\tMath.abs(bend) >\n\t\tMath.abs(shape.props.bend * (WAY_TOO_BIG_ARROW_BEND_FACTOR * shape.props.scale))\n\t) {\n\t\treturn getStraightArrowInfo(editor, shape, bindings)\n\t}\n\n\tconst terminalsInArrowSpace = getArrowTerminalsInArrowSpace(editor, shape, bindings)\n\n\tconst med = Vec.Med(terminalsInArrowSpace.start, terminalsInArrowSpace.end) // point between start and end\n\tconst distance = Vec.Sub(terminalsInArrowSpace.end, terminalsInArrowSpace.start)\n\t// Check for divide-by-zero before we call uni()\n\tconst u = Vec.Len(distance) ? distance.uni() : Vec.From(distance) // unit vector between start and end\n\tconst middle = Vec.Add(med, u.per().mul(-bend)) // middle handle\n\n\tconst startShapeInfo = getBoundShapeInfoForTerminal(editor, shape, 'start')\n\tconst endShapeInfo = getBoundShapeInfoForTerminal(editor, shape, 'end')\n\n\t// The positions of the body of the arrow, which may be different\n\t// than the arrow's start / end points if the arrow is bound to shapes\n\tconst a = terminalsInArrowSpace.start.clone()\n\tconst b = terminalsInArrowSpace.end.clone()\n\tconst c = middle.clone()\n\n\tif (Vec.Equals(a, b)) {\n\t\treturn {\n\t\t\tbindings,\n\t\t\tisStraight: true,\n\t\t\tstart: {\n\t\t\t\thandle: a,\n\t\t\t\tpoint: a,\n\t\t\t\tarrowhead: shape.props.arrowheadStart,\n\t\t\t},\n\t\t\tend: {\n\t\t\t\thandle: b,\n\t\t\t\tpoint: b,\n\t\t\t\tarrowhead: shape.props.arrowheadEnd,\n\t\t\t},\n\t\t\tmiddle: c,\n\t\t\tisValid: false,\n\t\t\tlength: 0,\n\t\t}\n\t}\n\n\tconst isClockwise = shape.props.bend < 0\n\tconst distFn = isClockwise ? clockwiseAngleDist : counterClockwiseAngleDist\n\n\tconst handleArc = getArcInfo(a, b, c)\n\tconst handle_aCA = Vec.Angle(handleArc.center, a)\n\tconst handle_aCB = Vec.Angle(handleArc.center, b)\n\tconst handle_dAB = distFn(handle_aCA, handle_aCB)\n\n\tif (\n\t\thandleArc.length === 0 ||\n\t\thandleArc.size === 0 ||\n\t\t!isSafeFloat(handleArc.length) ||\n\t\t!isSafeFloat(handleArc.size)\n\t) {\n\t\treturn getStraightArrowInfo(editor, shape, bindings)\n\t}\n\n\tconst tempA = a.clone()\n\tconst tempB = b.clone()\n\tconst tempC = c.clone()\n\n\tconst arrowPageTransform = editor.getShapePageTransform(shape)!\n\n\tlet offsetA = 0\n\tlet offsetB = 0\n\n\tlet minLength = MIN_ARROW_LENGTH * shape.props.scale\n\n\tif (startShapeInfo && !startShapeInfo.isExact) {\n\t\tconst startInPageSpace = Mat.applyToPoint(arrowPageTransform, tempA)\n\t\tconst centerInPageSpace = Mat.applyToPoint(arrowPageTransform, handleArc.center)\n\t\tconst endInPageSpace = Mat.applyToPoint(arrowPageTransform, tempB)\n\n\t\tconst inverseTransform = Mat.Inverse(startShapeInfo.transform)\n\n\t\tconst startInStartShapeLocalSpace = Mat.applyToPoint(inverseTransform, startInPageSpace)\n\t\tconst centerInStartShapeLocalSpace = Mat.applyToPoint(inverseTransform, centerInPageSpace)\n\t\tconst endInStartShapeLocalSpace = Mat.applyToPoint(inverseTransform, endInPageSpace)\n\n\t\tconst { isClosed } = startShapeInfo\n\t\tconst fn = isClosed ? intersectCirclePolygon : intersectCirclePolyline\n\n\t\tlet point: VecLike | undefined\n\n\t\tlet intersections = fn(centerInStartShapeLocalSpace, handleArc.radius, startShapeInfo.outline)\n\n\t\tif (intersections) {\n\t\t\tconst angleToStart = centerInStartShapeLocalSpace.angle(startInStartShapeLocalSpace)\n\t\t\tconst angleToEnd = centerInStartShapeLocalSpace.angle(endInStartShapeLocalSpace)\n\t\t\tconst dAB = distFn(angleToStart, angleToEnd)\n\n\t\t\t// Filter out any intersections that aren't in the arc\n\t\t\tintersections = intersections.filter(\n\t\t\t\t(pt) => distFn(angleToStart, centerInStartShapeLocalSpace.angle(pt)) <= dAB\n\t\t\t)\n\n\t\t\tconst targetDist = dAB * 0.25\n\n\t\t\tintersections.sort(\n\t\t\t\tisClosed\n\t\t\t\t\t? (p0, p1) =>\n\t\t\t\t\t\t\tMath.abs(distFn(angleToStart, centerInStartShapeLocalSpace.angle(p0)) - targetDist) <\n\t\t\t\t\t\t\tMath.abs(distFn(angleToStart, centerInStartShapeLocalSpace.angle(p1)) - targetDist)\n\t\t\t\t\t\t\t\t? -1\n\t\t\t\t\t\t\t\t: 1\n\t\t\t\t\t: (p0, p1) =>\n\t\t\t\t\t\t\tdistFn(angleToStart, centerInStartShapeLocalSpace.angle(p0)) <\n\t\t\t\t\t\t\tdistFn(angleToStart, centerInStartShapeLocalSpace.angle(p1))\n\t\t\t\t\t\t\t\t? -1\n\t\t\t\t\t\t\t\t: 1\n\t\t\t)\n\n\t\t\tpoint = intersections[0] ?? (isClosed ? undefined : startInStartShapeLocalSpace)\n\t\t} else {\n\t\t\tpoint = isClosed ? undefined : startInStartShapeLocalSpace\n\t\t}\n\n\t\tif (point) {\n\t\t\ttempA.setTo(\n\t\t\t\teditor.getPointInShapeSpace(shape, Mat.applyToPoint(startShapeInfo.transform, point))\n\t\t\t)\n\n\t\t\tstartShapeInfo.didIntersect = true\n\n\t\t\tif (arrowheadStart !== 'none') {\n\t\t\t\tconst strokeOffset =\n\t\t\t\t\tSTROKE_SIZES[shape.props.size] / 2 +\n\t\t\t\t\t('size' in startShapeInfo.shape.props\n\t\t\t\t\t\t? STROKE_SIZES[startShapeInfo.shape.props.size] / 2\n\t\t\t\t\t\t: 0)\n\t\t\t\toffsetA = (BOUND_ARROW_OFFSET + strokeOffset) * shape.props.scale\n\t\t\t\tminLength += strokeOffset * shape.props.scale\n\t\t\t}\n\t\t}\n\t}\n\n\tif (endShapeInfo && !endShapeInfo.isExact) {\n\t\t// get points in shape's coordinates?\n\t\tconst startInPageSpace = Mat.applyToPoint(arrowPageTransform, tempA)\n\t\tconst endInPageSpace = Mat.applyToPoint(arrowPageTransform, tempB)\n\t\tconst centerInPageSpace = Mat.applyToPoint(arrowPageTransform, handleArc.center)\n\n\t\tconst inverseTransform = Mat.Inverse(endShapeInfo.transform)\n\n\t\tconst startInEndShapeLocalSpace = Mat.applyToPoint(inverseTransform, startInPageSpace)\n\t\tconst centerInEndShapeLocalSpace = Mat.applyToPoint(inverseTransform, centerInPageSpace)\n\t\tconst endInEndShapeLocalSpace = Mat.applyToPoint(inverseTransform, endInPageSpace)\n\n\t\tconst isClosed = endShapeInfo.isClosed\n\t\tconst fn = isClosed ? intersectCirclePolygon : intersectCirclePolyline\n\n\t\tlet point: VecLike | undefined\n\n\t\tlet intersections = fn(centerInEndShapeLocalSpace, handleArc.radius, endShapeInfo.outline)\n\n\t\tif (intersections) {\n\t\t\tconst angleToStart = centerInEndShapeLocalSpace.angle(startInEndShapeLocalSpace)\n\t\t\tconst angleToEnd = centerInEndShapeLocalSpace.angle(endInEndShapeLocalSpace)\n\t\t\tconst dAB = distFn(angleToStart, angleToEnd)\n\t\t\tconst targetDist = dAB * 0.75\n\n\t\t\t// or simplified...\n\n\t\t\tintersections = intersections.filter(\n\t\t\t\t(pt) => distFn(angleToStart, centerInEndShapeLocalSpace.angle(pt)) <= dAB\n\t\t\t)\n\n\t\t\tintersections.sort(\n\t\t\t\tisClosed\n\t\t\t\t\t? (p0, p1) =>\n\t\t\t\t\t\t\tMath.abs(distFn(angleToStart, centerInEndShapeLocalSpace.angle(p0)) - targetDist) <\n\t\t\t\t\t\t\tMath.abs(distFn(angleToStart, centerInEndShapeLocalSpace.angle(p1)) - targetDist)\n\t\t\t\t\t\t\t\t? -1\n\t\t\t\t\t\t\t\t: 1\n\t\t\t\t\t: (p0, p1) =>\n\t\t\t\t\t\t\tdistFn(angleToStart, centerInEndShapeLocalSpace.angle(p0)) <\n\t\t\t\t\t\t\tdistFn(angleToStart, centerInEndShapeLocalSpace.angle(p1))\n\t\t\t\t\t\t\t\t? -1\n\t\t\t\t\t\t\t\t: 1\n\t\t\t)\n\n\t\t\tif (intersections[0]) {\n\t\t\t\tpoint = intersections[0]\n\t\t\t} else {\n\t\t\t\tpoint = isClosed ? undefined : endInEndShapeLocalSpace\n\t\t\t}\n\t\t} else {\n\t\t\tpoint = isClosed ? undefined : endInEndShapeLocalSpace\n\t\t}\n\n\t\tif (point) {\n\t\t\t// Set b to target local point -> page point -> shape local point\n\t\t\ttempB.setTo(\n\t\t\t\teditor.getPointInShapeSpace(shape, Mat.applyToPoint(endShapeInfo.transform, point))\n\t\t\t)\n\n\t\t\tendShapeInfo.didIntersect = true\n\n\t\t\tif (arrowheadEnd !== 'none') {\n\t\t\t\tconst strokeOffset =\n\t\t\t\t\tSTROKE_SIZES[shape.props.size] / 2 +\n\t\t\t\t\t('size' in endShapeInfo.shape.props ? STROKE_SIZES[endShapeInfo.shape.props.size] / 2 : 0)\n\t\t\t\toffsetB = (BOUND_ARROW_OFFSET + strokeOffset) * shape.props.scale\n\t\t\t\tminLength += strokeOffset * shape.props.scale\n\t\t\t}\n\t\t}\n\t}\n\n\t// Apply arrowhead offsets\n\n\tlet aCA = Vec.Angle(handleArc.center, tempA) // angle center -> a\n\tlet aCB = Vec.Angle(handleArc.center, tempB) // angle center -> b\n\tlet dAB = distFn(aCA, aCB) // angle distance between a and b\n\tlet lAB = dAB * handleArc.radius // length of arc between a and b\n\n\t// Try the offsets first, then check whether the distance between the points is too small;\n\t// if it is, flip the offsets and expand them. We need to do this using temporary points\n\t// so that we can apply them both in a balanced way.\n\tconst tA = tempA.clone()\n\tconst tB = tempB.clone()\n\n\tif (offsetA !== 0) {\n\t\ttA.setTo(handleArc.center).add(\n\t\t\tVec.FromAngle(aCA + dAB * ((offsetA / lAB) * (isClockwise ? 1 : -1))).mul(handleArc.radius)\n\t\t)\n\t}\n\n\tif (offsetB !== 0) {\n\t\ttB.setTo(handleArc.center).add(\n\t\t\tVec.FromAngle(aCB + dAB * ((offsetB / lAB) * (isClockwise ? -1 : 1))).mul(handleArc.radius)\n\t\t)\n\t}\n\n\tif (Vec.DistMin(tA, tB, minLength)) {\n\t\tif (offsetA !== 0 && offsetB !== 0) {\n\t\t\toffsetA *= -1.5\n\t\t\toffsetB *= -1.5\n\t\t} else if (offsetA !== 0) {\n\t\t\toffsetA *= -2\n\t\t} else if (offsetB !== 0) {\n\t\t\toffsetB *= -2\n\t\t} else {\n\t\t\t// noop\n\t\t}\n\t}\n\n\tif (offsetA !== 0) {\n\t\ttempA\n\t\t\t.setTo(handleArc.center)\n\t\t\t.add(\n\t\t\t\tVec.FromAngle(aCA + dAB * ((offsetA / lAB) * (isClockwise ? 1 : -1))).mul(handleArc.radius)\n\t\t\t)\n\t}\n\n\tif (offsetB !== 0) {\n\t\ttempB\n\t\t\t.setTo(handleArc.center)\n\t\t\t.add(\n\t\t\t\tVec.FromAngle(aCB + dAB * ((offsetB / lAB) * (isClockwise ? -1 : 1))).mul(handleArc.radius)\n\t\t\t)\n\t}\n\n\t// Did we miss intersections? This happens when we have overlapping shapes.\n\tif (startShapeInfo && endShapeInfo && !startShapeInfo.isExact && !endShapeInfo.isExact) {\n\t\taCA = Vec.Angle(handleArc.center, tempA) // angle center -> a\n\t\taCB = Vec.Angle(handleArc.center, tempB) // angle center -> b\n\t\tdAB = distFn(aCA, aCB) // angle distance between a and b\n\t\tlAB = dAB * handleArc.radius // length of arc between a and b\n\t\tconst relationship = getBoundShapeRelationships(\n\t\t\teditor,\n\t\t\tstartShapeInfo.shape.id,\n\t\t\tendShapeInfo.shape.id\n\t\t)\n\n\t\tif (relationship === 'double-bound' && lAB < 30) {\n\t\t\ttempA.setTo(a)\n\t\t\ttempB.setTo(b)\n\t\t\ttempC.setTo(c)\n\t\t} else if (relationship === 'safe') {\n\t\t\tif (startShapeInfo && !startShapeInfo.didIntersect) {\n\t\t\t\ttempA.setTo(a)\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t(endShapeInfo && !endShapeInfo.didIntersect) ||\n\t\t\t\tdistFn(handle_aCA, aCA) > distFn(handle_aCA, aCB)\n\t\t\t) {\n\t\t\t\ttempB\n\t\t\t\t\t.setTo(handleArc.center)\n\t\t\t\t\t.add(\n\t\t\t\t\t\tVec.FromAngle(\n\t\t\t\t\t\t\taCA +\n\t\t\t\t\t\t\t\tdAB *\n\t\t\t\t\t\t\t\t\t(Math.min(0.9, (MIN_ARROW_LENGTH * shape.props.scale) / lAB) *\n\t\t\t\t\t\t\t\t\t\t(isClockwise ? 1 : -1))\n\t\t\t\t\t\t).mul(handleArc.radius)\n\t\t\t\t\t)\n\t\t\t}\n\t\t}\n\t}\n\n\tplaceCenterHandle(\n\t\thandleArc.center,\n\t\thandleArc.radius,\n\t\ttempA,\n\t\ttempB,\n\t\ttempC,\n\t\thandle_dAB,\n\t\tisClockwise\n\t)\n\n\tif (tempA.equals(tempB)) {\n\t\ttempA.setTo(tempC.clone().addXY(1, 1))\n\t\ttempB.setTo(tempC.clone().subXY(1, 1))\n\t}\n\n\ta.setTo(tempA)\n\tb.setTo(tempB)\n\tc.setTo(tempC)\n\tconst bodyArc = getArcInfo(a, b, c)\n\n\treturn {\n\t\tbindings,\n\t\tisStraight: false,\n\t\tstart: {\n\t\t\tpoint: a,\n\t\t\thandle: terminalsInArrowSpace.start,\n\t\t\tarrowhead: shape.props.arrowheadStart,\n\t\t},\n\t\tend: {\n\t\t\tpoint: b,\n\t\t\thandle: terminalsInArrowSpace.end,\n\t\t\tarrowhead: shape.props.arrowheadEnd,\n\t\t},\n\t\tmiddle: c,\n\t\thandleArc,\n\t\tbodyArc,\n\t\tisValid: bodyArc.length !== 0 && isFinite(bodyArc.center.x) && isFinite(bodyArc.center.y),\n\t}\n}\n\n/**\n * Get info about an arc formed by three points.\n *\n * @param a - The start of the arc\n * @param b - The end of the arc\n * @param c - A point on the arc\n */\nfunction getArcInfo(a: VecLike, b: VecLike, c: VecLike): TLArcInfo {\n\t// find a circle from the three points\n\tconst center = centerOfCircleFromThreePoints(a, b, c) ?? Vec.Med(a, b)\n\n\tconst radius = Vec.Dist(center, a)\n\n\t// Whether to draw the arc clockwise or counter-clockwise (are the points clockwise?)\n\tconst sweepFlag = +Vec.Clockwise(a, c, b)\n\n\t// The base angle of the arc in radians\n\tconst ab = ((a.y - b.y) ** 2 + (a.x - b.x) ** 2) ** 0.5\n\tconst bc = ((b.y - c.y) ** 2 + (b.x - c.x) ** 2) ** 0.5\n\tconst ca = ((c.y - a.y) ** 2 + (c.x - a.x) ** 2) ** 0.5\n\n\tconst theta = Math.acos((bc * bc + ca * ca - ab * ab) / (2 * bc * ca)) * 2\n\n\t// Whether to draw the long arc or short arc\n\tconst largeArcFlag = +(PI > theta)\n\n\t// The size of the arc to draw in radians\n\tconst size = (PI2 - theta) * (sweepFlag ? 1 : -1)\n\n\t// The length of the arc to draw in distance units\n\tconst length = size * radius\n\n\treturn {\n\t\tcenter,\n\t\tradius,\n\t\tsize,\n\t\tlength,\n\t\tlargeArcFlag,\n\t\tsweepFlag,\n\t}\n}\n\nfunction placeCenterHandle(\n\tcenter: VecLike,\n\tradius: number,\n\ttempA: Vec,\n\ttempB: Vec,\n\ttempC: Vec,\n\toriginalArcLength: number,\n\tisClockwise: boolean\n) {\n\tconst aCA = Vec.Angle(center, tempA) // angle center -> a\n\tconst aCB = Vec.Angle(center, tempB) // angle center -> b\n\tlet dAB = clockwiseAngleDist(aCA, aCB) // angle distance between a and b\n\tif (!isClockwise) dAB = PI2 - dAB\n\n\ttempC.setTo(center).add(Vec.FromAngle(aCA + dAB * (0.5 * (isClockwise ? 1 : -1))).mul(radius))\n\n\tif (dAB > originalArcLength) {\n\t\ttempC.rotWith(center, PI)\n\t\tconst t = tempB.clone()\n\t\ttempB.setTo(tempA)\n\t\ttempA.setTo(t)\n\t}\n}\n"],
  "mappings": "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",
  "names": ["dAB"]
}
