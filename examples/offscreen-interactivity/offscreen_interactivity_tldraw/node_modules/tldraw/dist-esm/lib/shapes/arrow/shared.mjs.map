{
  "version": 3,
  "sources": ["../../../../src/lib/shapes/arrow/shared.ts"],
  "sourcesContent": ["import {\n\tEditor,\n\tGroup2d,\n\tMat,\n\tTLArrowBinding,\n\tTLArrowBindingProps,\n\tTLArrowShape,\n\tTLShape,\n\tTLShapeId,\n\tVec,\n} from '@tldraw/editor'\nimport { createComputedCache } from '@tldraw/store'\nimport { getCurvedArrowInfo } from './curved-arrow'\nimport { getStraightArrowInfo } from './straight-arrow'\n\nconst MIN_ARROW_BEND = 8\n\nexport function getIsArrowStraight(shape: TLArrowShape) {\n\treturn Math.abs(shape.props.bend) < MIN_ARROW_BEND * shape.props.scale // snap to +-8px\n}\n\nexport interface BoundShapeInfo<T extends TLShape = TLShape> {\n\tshape: T\n\tdidIntersect: boolean\n\tisExact: boolean\n\tisClosed: boolean\n\ttransform: Mat\n\toutline: Vec[]\n}\n\nexport function getBoundShapeInfoForTerminal(\n\teditor: Editor,\n\tarrow: TLArrowShape,\n\tterminalName: 'start' | 'end'\n): BoundShapeInfo | undefined {\n\tconst binding = editor\n\t\t.getBindingsFromShape<TLArrowBinding>(arrow, 'arrow')\n\t\t.find((b) => b.props.terminal === terminalName)\n\tif (!binding) return\n\n\tconst boundShape = editor.getShape(binding.toId)!\n\tif (!boundShape) return\n\tconst transform = editor.getShapePageTransform(boundShape)!\n\tconst geometry = editor.getShapeGeometry(boundShape)\n\n\t// This is hacky: we're only looking at the first child in the group. Really the arrow should\n\t// consider all items in the group which are marked as snappable as separate polygons with which\n\t// to intersect, in the case of a group that has multiple children which do not overlap; or else\n\t// flatten the geometry into a set of polygons and intersect with that.\n\tconst outline = geometry instanceof Group2d ? geometry.children[0].vertices : geometry.vertices\n\n\treturn {\n\t\tshape: boundShape,\n\t\ttransform,\n\t\tisClosed: geometry.isClosed,\n\t\tisExact: binding.props.isExact,\n\t\tdidIntersect: false,\n\t\toutline,\n\t}\n}\n\nfunction getArrowTerminalInArrowSpace(\n\teditor: Editor,\n\tarrowPageTransform: Mat,\n\tbinding: TLArrowBinding,\n\tforceImprecise: boolean\n) {\n\tconst boundShape = editor.getShape(binding.toId)\n\n\tif (!boundShape) {\n\t\t// this can happen in multiplayer contexts where the shape is being deleted\n\t\treturn new Vec(0, 0)\n\t} else {\n\t\t// Find the actual local point of the normalized terminal on\n\t\t// the bound shape and transform it to page space, then transform\n\t\t// it to arrow space\n\t\tconst { point, size } = editor.getShapeGeometry(boundShape).bounds\n\t\tconst shapePoint = Vec.Add(\n\t\t\tpoint,\n\t\t\tVec.MulV(\n\t\t\t\t// if the parent is the bound shape, then it's ALWAYS precise\n\t\t\t\tbinding.props.isPrecise || forceImprecise\n\t\t\t\t\t? binding.props.normalizedAnchor\n\t\t\t\t\t: { x: 0.5, y: 0.5 },\n\t\t\t\tsize\n\t\t\t)\n\t\t)\n\t\tconst pagePoint = Mat.applyToPoint(editor.getShapePageTransform(boundShape)!, shapePoint)\n\t\tconst arrowPoint = Mat.applyToPoint(Mat.Inverse(arrowPageTransform), pagePoint)\n\t\treturn arrowPoint\n\t}\n}\n\n/** @public */\nexport interface TLArrowBindings {\n\tstart: TLArrowBinding | undefined\n\tend: TLArrowBinding | undefined\n}\n\n/** @public */\nexport function getArrowBindings(editor: Editor, shape: TLArrowShape): TLArrowBindings {\n\tconst bindings = editor.getBindingsFromShape<TLArrowBinding>(shape, 'arrow')\n\treturn {\n\t\tstart: bindings.find((b) => b.props.terminal === 'start'),\n\t\tend: bindings.find((b) => b.props.terminal === 'end'),\n\t}\n}\n\nconst arrowInfoCache = createComputedCache('arrow info', (editor: Editor, shape: TLArrowShape) => {\n\tconst bindings = getArrowBindings(editor, shape)\n\treturn getIsArrowStraight(shape)\n\t\t? getStraightArrowInfo(editor, shape, bindings)\n\t\t: getCurvedArrowInfo(editor, shape, bindings)\n})\n\n/** @public */\nexport function getArrowInfo(editor: Editor, shape: TLArrowShape | TLShapeId) {\n\tconst id = typeof shape === 'string' ? shape : shape.id\n\treturn arrowInfoCache.get(editor, id)\n}\n\n/** @public */\nexport function getArrowTerminalsInArrowSpace(\n\teditor: Editor,\n\tshape: TLArrowShape,\n\tbindings: TLArrowBindings\n) {\n\tconst arrowPageTransform = editor.getShapePageTransform(shape)!\n\n\tconst boundShapeRelationships = getBoundShapeRelationships(\n\t\teditor,\n\t\tbindings.start?.toId,\n\t\tbindings.end?.toId\n\t)\n\n\tconst start = bindings.start\n\t\t? getArrowTerminalInArrowSpace(\n\t\t\t\teditor,\n\t\t\t\tarrowPageTransform,\n\t\t\t\tbindings.start,\n\t\t\t\tboundShapeRelationships === 'double-bound' ||\n\t\t\t\t\tboundShapeRelationships === 'start-contains-end'\n\t\t\t)\n\t\t: Vec.From(shape.props.start)\n\n\tconst end = bindings.end\n\t\t? getArrowTerminalInArrowSpace(\n\t\t\t\teditor,\n\t\t\t\tarrowPageTransform,\n\t\t\t\tbindings.end,\n\t\t\t\tboundShapeRelationships === 'double-bound' ||\n\t\t\t\t\tboundShapeRelationships === 'end-contains-start'\n\t\t\t)\n\t\t: Vec.From(shape.props.end)\n\n\treturn { start, end }\n}\n\n/**\n * Create or update the arrow binding for a particular arrow terminal. Will clear up if needed.\n * @internal\n */\nexport function createOrUpdateArrowBinding(\n\teditor: Editor,\n\tarrow: TLArrowShape | TLShapeId,\n\ttarget: TLShape | TLShapeId,\n\tprops: TLArrowBindingProps\n) {\n\tconst arrowId = typeof arrow === 'string' ? arrow : arrow.id\n\tconst targetId = typeof target === 'string' ? target : target.id\n\n\tconst existingMany = editor\n\t\t.getBindingsFromShape<TLArrowBinding>(arrowId, 'arrow')\n\t\t.filter((b) => b.props.terminal === props.terminal)\n\n\t// if we've somehow ended up with too many bindings, delete the extras\n\tif (existingMany.length > 1) {\n\t\teditor.deleteBindings(existingMany.slice(1))\n\t}\n\n\tconst existing = existingMany[0]\n\tif (existing) {\n\t\teditor.updateBinding({\n\t\t\t...existing,\n\t\t\ttoId: targetId,\n\t\t\tprops,\n\t\t})\n\t} else {\n\t\teditor.createBinding({\n\t\t\ttype: 'arrow',\n\t\t\tfromId: arrowId,\n\t\t\ttoId: targetId,\n\t\t\tprops,\n\t\t})\n\t}\n}\n\n/**\n * Remove any arrow bindings for a particular terminal.\n * @internal\n */\nexport function removeArrowBinding(editor: Editor, arrow: TLArrowShape, terminal: 'start' | 'end') {\n\tconst existing = editor\n\t\t.getBindingsFromShape<TLArrowBinding>(arrow, 'arrow')\n\t\t.filter((b) => b.props.terminal === terminal)\n\n\teditor.deleteBindings(existing)\n}\n\n/** @internal */\nexport const MIN_ARROW_LENGTH = 10\n/** @internal */\nexport const BOUND_ARROW_OFFSET = 10\n/** @internal */\nexport const WAY_TOO_BIG_ARROW_BEND_FACTOR = 10\n\n/** @public */\nexport const STROKE_SIZES: Record<string, number> = {\n\ts: 2,\n\tm: 3.5,\n\tl: 5,\n\txl: 10,\n}\n\n/**\n * Get the relationships for an arrow that has two bound shape terminals.\n * If the arrow has only one bound shape, then it is always \"safe\" to apply\n * standard offsets and precision behavior. If the shape is bound to the same\n * shape on both ends, then that is an exception. If one of the shape's\n * terminals is bound to a shape that contains / is contained by the shape that\n * is bound to the other terminal, then that is also an exception.\n *\n * @param editor - the editor instance\n * @param startShapeId - the bound shape from the arrow's start\n * @param endShapeId - the bound shape from the arrow's end\n *\n *  @internal */\nexport function getBoundShapeRelationships(\n\teditor: Editor,\n\tstartShapeId?: TLShapeId,\n\tendShapeId?: TLShapeId\n) {\n\tif (!startShapeId || !endShapeId) return 'safe'\n\tif (startShapeId === endShapeId) return 'double-bound'\n\tconst startBounds = editor.getShapePageBounds(startShapeId)\n\tconst endBounds = editor.getShapePageBounds(endShapeId)\n\tif (startBounds && endBounds) {\n\t\tif (startBounds.contains(endBounds)) return 'start-contains-end'\n\t\tif (endBounds.contains(startBounds)) return 'end-contains-start'\n\t}\n\treturn 'safe'\n}\n"],
  "mappings": "AAAA;AAAA,EAEC;AAAA,EACA;AAAA,EAMA;AAAA,OACM;AACP,SAAS,2BAA2B;AACpC,SAAS,0BAA0B;AACnC,SAAS,4BAA4B;AAErC,MAAM,iBAAiB;AAEhB,SAAS,mBAAmB,OAAqB;AACvD,SAAO,KAAK,IAAI,MAAM,MAAM,IAAI,IAAI,iBAAiB,MAAM,MAAM;AAClE;AAWO,SAAS,6BACf,QACA,OACA,cAC6B;AAC7B,QAAM,UAAU,OACd,qBAAqC,OAAO,OAAO,EACnD,KAAK,CAAC,MAAM,EAAE,MAAM,aAAa,YAAY;AAC/C,MAAI,CAAC,QAAS;AAEd,QAAM,aAAa,OAAO,SAAS,QAAQ,IAAI;AAC/C,MAAI,CAAC,WAAY;AACjB,QAAM,YAAY,OAAO,sBAAsB,UAAU;AACzD,QAAM,WAAW,OAAO,iBAAiB,UAAU;AAMnD,QAAM,UAAU,oBAAoB,UAAU,SAAS,SAAS,CAAC,EAAE,WAAW,SAAS;AAEvF,SAAO;AAAA,IACN,OAAO;AAAA,IACP;AAAA,IACA,UAAU,SAAS;AAAA,IACnB,SAAS,QAAQ,MAAM;AAAA,IACvB,cAAc;AAAA,IACd;AAAA,EACD;AACD;AAEA,SAAS,6BACR,QACA,oBACA,SACA,gBACC;AACD,QAAM,aAAa,OAAO,SAAS,QAAQ,IAAI;AAE/C,MAAI,CAAC,YAAY;AAEhB,WAAO,IAAI,IAAI,GAAG,CAAC;AAAA,EACpB,OAAO;AAIN,UAAM,EAAE,OAAO,KAAK,IAAI,OAAO,iBAAiB,UAAU,EAAE;AAC5D,UAAM,aAAa,IAAI;AAAA,MACtB;AAAA,MACA,IAAI;AAAA;AAAA,QAEH,QAAQ,MAAM,aAAa,iBACxB,QAAQ,MAAM,mBACd,EAAE,GAAG,KAAK,GAAG,IAAI;AAAA,QACpB;AAAA,MACD;AAAA,IACD;AACA,UAAM,YAAY,IAAI,aAAa,OAAO,sBAAsB,UAAU,GAAI,UAAU;AACxF,UAAM,aAAa,IAAI,aAAa,IAAI,QAAQ,kBAAkB,GAAG,SAAS;AAC9E,WAAO;AAAA,EACR;AACD;AASO,SAAS,iBAAiB,QAAgB,OAAsC;AACtF,QAAM,WAAW,OAAO,qBAAqC,OAAO,OAAO;AAC3E,SAAO;AAAA,IACN,OAAO,SAAS,KAAK,CAAC,MAAM,EAAE,MAAM,aAAa,OAAO;AAAA,IACxD,KAAK,SAAS,KAAK,CAAC,MAAM,EAAE,MAAM,aAAa,KAAK;AAAA,EACrD;AACD;AAEA,MAAM,iBAAiB,oBAAoB,cAAc,CAAC,QAAgB,UAAwB;AACjG,QAAM,WAAW,iBAAiB,QAAQ,KAAK;AAC/C,SAAO,mBAAmB,KAAK,IAC5B,qBAAqB,QAAQ,OAAO,QAAQ,IAC5C,mBAAmB,QAAQ,OAAO,QAAQ;AAC9C,CAAC;AAGM,SAAS,aAAa,QAAgB,OAAiC;AAC7E,QAAM,KAAK,OAAO,UAAU,WAAW,QAAQ,MAAM;AACrD,SAAO,eAAe,IAAI,QAAQ,EAAE;AACrC;AAGO,SAAS,8BACf,QACA,OACA,UACC;AACD,QAAM,qBAAqB,OAAO,sBAAsB,KAAK;AAE7D,QAAM,0BAA0B;AAAA,IAC/B;AAAA,IACA,SAAS,OAAO;AAAA,IAChB,SAAS,KAAK;AAAA,EACf;AAEA,QAAM,QAAQ,SAAS,QACpB;AAAA,IACA;AAAA,IACA;AAAA,IACA,SAAS;AAAA,IACT,4BAA4B,kBAC3B,4BAA4B;AAAA,EAC9B,IACC,IAAI,KAAK,MAAM,MAAM,KAAK;AAE7B,QAAM,MAAM,SAAS,MAClB;AAAA,IACA;AAAA,IACA;AAAA,IACA,SAAS;AAAA,IACT,4BAA4B,kBAC3B,4BAA4B;AAAA,EAC9B,IACC,IAAI,KAAK,MAAM,MAAM,GAAG;AAE3B,SAAO,EAAE,OAAO,IAAI;AACrB;AAMO,SAAS,2BACf,QACA,OACA,QACA,OACC;AACD,QAAM,UAAU,OAAO,UAAU,WAAW,QAAQ,MAAM;AAC1D,QAAM,WAAW,OAAO,WAAW,WAAW,SAAS,OAAO;AAE9D,QAAM,eAAe,OACnB,qBAAqC,SAAS,OAAO,EACrD,OAAO,CAAC,MAAM,EAAE,MAAM,aAAa,MAAM,QAAQ;AAGnD,MAAI,aAAa,SAAS,GAAG;AAC5B,WAAO,eAAe,aAAa,MAAM,CAAC,CAAC;AAAA,EAC5C;AAEA,QAAM,WAAW,aAAa,CAAC;AAC/B,MAAI,UAAU;AACb,WAAO,cAAc;AAAA,MACpB,GAAG;AAAA,MACH,MAAM;AAAA,MACN;AAAA,IACD,CAAC;AAAA,EACF,OAAO;AACN,WAAO,cAAc;AAAA,MACpB,MAAM;AAAA,MACN,QAAQ;AAAA,MACR,MAAM;AAAA,MACN;AAAA,IACD,CAAC;AAAA,EACF;AACD;AAMO,SAAS,mBAAmB,QAAgB,OAAqB,UAA2B;AAClG,QAAM,WAAW,OACf,qBAAqC,OAAO,OAAO,EACnD,OAAO,CAAC,MAAM,EAAE,MAAM,aAAa,QAAQ;AAE7C,SAAO,eAAe,QAAQ;AAC/B;AAGO,MAAM,mBAAmB;AAEzB,MAAM,qBAAqB;AAE3B,MAAM,gCAAgC;AAGtC,MAAM,eAAuC;AAAA,EACnD,GAAG;AAAA,EACH,GAAG;AAAA,EACH,GAAG;AAAA,EACH,IAAI;AACL;AAeO,SAAS,2BACf,QACA,cACA,YACC;AACD,MAAI,CAAC,gBAAgB,CAAC,WAAY,QAAO;AACzC,MAAI,iBAAiB,WAAY,QAAO;AACxC,QAAM,cAAc,OAAO,mBAAmB,YAAY;AAC1D,QAAM,YAAY,OAAO,mBAAmB,UAAU;AACtD,MAAI,eAAe,WAAW;AAC7B,QAAI,YAAY,SAAS,SAAS,EAAG,QAAO;AAC5C,QAAI,UAAU,SAAS,WAAW,EAAG,QAAO;AAAA,EAC7C;AACA,SAAO;AACR;",
  "names": []
}
