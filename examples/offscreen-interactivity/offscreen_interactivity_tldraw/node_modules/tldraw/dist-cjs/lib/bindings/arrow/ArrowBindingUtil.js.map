{
  "version": 3,
  "sources": ["../../../../src/lib/bindings/arrow/ArrowBindingUtil.ts"],
  "sourcesContent": ["import {\n\tBindingOnChangeOptions,\n\tBindingOnCreateOptions,\n\tBindingOnShapeChangeOptions,\n\tBindingOnShapeIsolateOptions,\n\tBindingUtil,\n\tEditor,\n\tIndexKey,\n\tTLArrowBinding,\n\tTLArrowBindingProps,\n\tTLArrowShape,\n\tTLParentId,\n\tTLShape,\n\tTLShapeId,\n\tTLShapePartial,\n\tVec,\n\tapproximately,\n\tarrowBindingMigrations,\n\tarrowBindingProps,\n\tassert,\n\tgetIndexAbove,\n\tgetIndexBetween,\n\tintersectLineSegmentCircle,\n} from '@tldraw/editor'\nimport { getArrowBindings, getArrowInfo, removeArrowBinding } from '../../shapes/arrow/shared'\n\n/**\n * @public\n */\nexport class ArrowBindingUtil extends BindingUtil<TLArrowBinding> {\n\tstatic override type = 'arrow'\n\n\tstatic override props = arrowBindingProps\n\tstatic override migrations = arrowBindingMigrations\n\n\toverride getDefaultProps(): Partial<TLArrowBindingProps> {\n\t\treturn {\n\t\t\tisPrecise: false,\n\t\t\tisExact: false,\n\t\t\tnormalizedAnchor: { x: 0.5, y: 0.5 },\n\t\t}\n\t}\n\n\t// when the binding itself changes\n\toverride onAfterCreate({ binding }: BindingOnCreateOptions<TLArrowBinding>): void {\n\t\tconst arrow = this.editor.getShape(binding.fromId) as TLArrowShape | undefined\n\t\tif (!arrow) return\n\t\tarrowDidUpdate(this.editor, arrow)\n\t}\n\n\t// when the binding itself changes\n\toverride onAfterChange({ bindingAfter }: BindingOnChangeOptions<TLArrowBinding>): void {\n\t\tconst arrow = this.editor.getShape(bindingAfter.fromId) as TLArrowShape | undefined\n\t\tif (!arrow) return\n\t\tarrowDidUpdate(this.editor, arrow)\n\t}\n\n\t// when the arrow itself changes\n\toverride onAfterChangeFromShape({\n\t\tshapeAfter,\n\t}: BindingOnShapeChangeOptions<TLArrowBinding>): void {\n\t\tarrowDidUpdate(this.editor, shapeAfter as TLArrowShape)\n\t}\n\n\t// when the shape an arrow is bound to changes\n\toverride onAfterChangeToShape({ binding }: BindingOnShapeChangeOptions<TLArrowBinding>): void {\n\t\treparentArrow(this.editor, binding.fromId)\n\t}\n\n\t// when the arrow is isolated we need to update it's x,y positions\n\toverride onBeforeIsolateFromShape({\n\t\tbinding,\n\t}: BindingOnShapeIsolateOptions<TLArrowBinding>): void {\n\t\tconst arrow = this.editor.getShape<TLArrowShape>(binding.fromId)\n\t\tif (!arrow) return\n\t\tupdateArrowTerminal({\n\t\t\teditor: this.editor,\n\t\t\tarrow,\n\t\t\tterminal: binding.props.terminal,\n\t\t})\n\t}\n}\n\nfunction reparentArrow(editor: Editor, arrowId: TLShapeId) {\n\tconst arrow = editor.getShape<TLArrowShape>(arrowId)\n\tif (!arrow) return\n\tconst bindings = getArrowBindings(editor, arrow)\n\tconst { start, end } = bindings\n\tconst startShape = start ? editor.getShape(start.toId) : undefined\n\tconst endShape = end ? editor.getShape(end.toId) : undefined\n\n\tconst parentPageId = editor.getAncestorPageId(arrow)\n\tif (!parentPageId) return\n\n\tlet nextParentId: TLParentId\n\tif (startShape && endShape) {\n\t\t// if arrow has two bindings, always parent arrow to closest common ancestor of the bindings\n\t\tnextParentId = editor.findCommonAncestor([startShape, endShape]) ?? parentPageId\n\t} else if (startShape || endShape) {\n\t\tconst bindingParentId = (startShape || endShape)?.parentId\n\t\t// If the arrow and the shape that it is bound to have the same parent, then keep that parent\n\t\tif (bindingParentId && bindingParentId === arrow.parentId) {\n\t\t\tnextParentId = arrow.parentId\n\t\t} else {\n\t\t\t// if arrow has one binding, keep arrow on its own page\n\t\t\tnextParentId = parentPageId\n\t\t}\n\t} else {\n\t\treturn\n\t}\n\n\tif (nextParentId && nextParentId !== arrow.parentId) {\n\t\teditor.reparentShapes([arrowId], nextParentId)\n\t}\n\n\tconst reparentedArrow = editor.getShape<TLArrowShape>(arrowId)\n\tif (!reparentedArrow) throw Error('no reparented arrow')\n\n\tconst startSibling = editor.getShapeNearestSibling(reparentedArrow, startShape)\n\tconst endSibling = editor.getShapeNearestSibling(reparentedArrow, endShape)\n\n\tlet highestSibling: TLShape | undefined\n\n\tif (startSibling && endSibling) {\n\t\thighestSibling = startSibling.index > endSibling.index ? startSibling : endSibling\n\t} else if (startSibling && !endSibling) {\n\t\thighestSibling = startSibling\n\t} else if (endSibling && !startSibling) {\n\t\thighestSibling = endSibling\n\t} else {\n\t\treturn\n\t}\n\n\tlet finalIndex: IndexKey\n\n\tconst higherSiblings = editor\n\t\t.getSortedChildIdsForParent(highestSibling.parentId)\n\t\t.map((id) => editor.getShape(id)!)\n\t\t.filter((sibling) => sibling.index > highestSibling!.index)\n\n\tif (higherSiblings.length) {\n\t\t// there are siblings above the highest bound sibling, we need to\n\t\t// insert between them.\n\n\t\t// if the next sibling is also a bound arrow though, we can end up\n\t\t// all fighting for the same indexes. so lets find the next\n\t\t// non-arrow sibling...\n\t\tconst nextHighestNonArrowSibling = higherSiblings.find((sibling) => sibling.type !== 'arrow')\n\n\t\tif (\n\t\t\t// ...then, if we're above the last shape we want to be above...\n\t\t\treparentedArrow.index > highestSibling.index &&\n\t\t\t// ...but below the next non-arrow sibling...\n\t\t\t(!nextHighestNonArrowSibling || reparentedArrow.index < nextHighestNonArrowSibling.index)\n\t\t) {\n\t\t\t// ...then we're already in the right place. no need to update!\n\t\t\treturn\n\t\t}\n\n\t\t// otherwise, we need to find the index between the highest sibling\n\t\t// we want to be above, and the next highest sibling we want to be\n\t\t// below:\n\t\tfinalIndex = getIndexBetween(highestSibling.index, higherSiblings[0].index)\n\t} else {\n\t\t// if there are no siblings above us, we can just get the next index:\n\t\tfinalIndex = getIndexAbove(highestSibling.index)\n\t}\n\n\tif (finalIndex !== reparentedArrow.index) {\n\t\teditor.updateShapes<TLArrowShape>([{ id: arrowId, type: 'arrow', index: finalIndex }])\n\t}\n}\n\nfunction arrowDidUpdate(editor: Editor, arrow: TLArrowShape) {\n\tconst bindings = getArrowBindings(editor, arrow)\n\t// if the shape is an arrow and its bound shape is on another page\n\t// or was deleted, unbind it\n\tfor (const handle of ['start', 'end'] as const) {\n\t\tconst binding = bindings[handle]\n\t\tif (!binding) continue\n\t\tconst boundShape = editor.getShape(binding.toId)\n\t\tconst isShapeInSamePageAsArrow =\n\t\t\teditor.getAncestorPageId(arrow) === editor.getAncestorPageId(boundShape)\n\t\tif (!boundShape || !isShapeInSamePageAsArrow) {\n\t\t\tupdateArrowTerminal({ editor, arrow, terminal: handle, unbind: true })\n\t\t}\n\t}\n\n\t// always check the arrow parents\n\treparentArrow(editor, arrow.id)\n}\n\n/** @internal */\nexport function updateArrowTerminal({\n\teditor,\n\tarrow,\n\tterminal,\n\tunbind = false,\n\tuseHandle = false,\n}: {\n\teditor: Editor\n\tarrow: TLArrowShape\n\tterminal: 'start' | 'end'\n\tunbind?: boolean\n\tuseHandle?: boolean\n}) {\n\tconst info = getArrowInfo(editor, arrow)\n\tif (!info) {\n\t\tthrow new Error('expected arrow info')\n\t}\n\n\tconst startPoint = useHandle ? info.start.handle : info.start.point\n\tconst endPoint = useHandle ? info.end.handle : info.end.point\n\tconst point = terminal === 'start' ? startPoint : endPoint\n\n\tconst update = {\n\t\tid: arrow.id,\n\t\ttype: 'arrow',\n\t\tprops: {\n\t\t\t[terminal]: { x: point.x, y: point.y },\n\t\t\tbend: arrow.props.bend,\n\t\t},\n\t} satisfies TLShapePartial<TLArrowShape>\n\n\t// fix up the bend:\n\tif (!info.isStraight) {\n\t\t// find the new start/end points of the resulting arrow\n\t\tconst newStart = terminal === 'start' ? startPoint : info.start.handle\n\t\tconst newEnd = terminal === 'end' ? endPoint : info.end.handle\n\t\tconst newMidPoint = Vec.Med(newStart, newEnd)\n\n\t\t// intersect a line segment perpendicular to the new arrow with the old arrow arc to\n\t\t// find the new mid-point\n\t\tconst lineSegment = Vec.Sub(newStart, newEnd)\n\t\t\t.per()\n\t\t\t.uni()\n\t\t\t.mul(info.handleArc.radius * 2 * Math.sign(arrow.props.bend))\n\n\t\t// find the intersections with the old arrow arc:\n\t\tconst intersections = intersectLineSegmentCircle(\n\t\t\tinfo.handleArc.center,\n\t\t\tVec.Add(newMidPoint, lineSegment),\n\t\t\tinfo.handleArc.center,\n\t\t\tinfo.handleArc.radius\n\t\t)\n\n\t\tassert(intersections?.length === 1)\n\t\tconst bend = Vec.Dist(newMidPoint, intersections[0]) * Math.sign(arrow.props.bend)\n\t\t// use `approximately` to avoid endless update loops\n\t\tif (!approximately(bend, update.props.bend)) {\n\t\t\tupdate.props.bend = bend\n\t\t}\n\t}\n\n\teditor.updateShape(update)\n\tif (unbind) {\n\t\tremoveArrowBinding(editor, arrow, terminal)\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
