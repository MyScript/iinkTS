{
  "version": 3,
  "sources": ["../../../src/lib/utils/clipboard.ts"],
  "sourcesContent": ["import { getOwnProperty, objectMapFromEntries } from '@tldraw/editor'\n\n// Browsers sanitize image formats to prevent security issues when pasting between applications. For\n// paste within an application though, some browsers (only chromium-based browsers as of Nov 2024)\n// support custom clipboard formats starting with \"web \" which are unsanitized. Our PNGs include a\n// special chunk which indicates they're at 2x resolution, but that normally gets stripped - so if\n// you copy as png from tldraw, then paste back in, the resulting image will be 2x the expected\n// size. To work around this, we write 2 version of the image to the clipboard - the normal png, and\n// the same blob with a custom mime type. When pasting, we check first for the custom mime type, and\n// if it's there, use that instead of the normal png.\nexport const TLDRAW_CUSTOM_PNG_MIME_TYPE = 'web image/vnd.tldraw+png' as const\n\nconst additionalClipboardWriteTypes = {\n\t'image/png': TLDRAW_CUSTOM_PNG_MIME_TYPE,\n} as const\nconst canonicalClipboardReadTypes = {\n\t[TLDRAW_CUSTOM_PNG_MIME_TYPE]: 'image/png',\n}\n\nexport function getAdditionalClipboardWriteType(mimeType: string): string | null {\n\treturn getOwnProperty(additionalClipboardWriteTypes, mimeType) ?? null\n}\nexport function getCanonicalClipboardReadType(mimeType: string): string {\n\treturn getOwnProperty(canonicalClipboardReadTypes, mimeType) ?? mimeType\n}\n\nexport function doesClipboardSupportType(mimeType: string): boolean {\n\treturn (\n\t\ttypeof ClipboardItem !== 'undefined' &&\n\t\t'supports' in ClipboardItem &&\n\t\t(ClipboardItem.supports as (type: string) => boolean)(mimeType)\n\t)\n}\n\nexport function clipboardWrite(types: Record<string, Promise<Blob>>): Promise<void> {\n\t// Note:  it's important that this function itself isn't async and doesn't really use promises -\n\t// we need to create the relevant `ClipboardItem`s and call navigator.clipboard.write\n\t// synchronously to make sure safari knows that the user _wants_ to copy See\n\t// https://bugs.webkit.org/show_bug.cgi?id=222262\n\n\tconst entries = Object.entries(types)\n\n\t// clipboard.write will swallow errors if any of the promises reject. we log them here so we can\n\t// understand what might have gone wrong.\n\tfor (const [_, promise] of entries) promise.catch((err) => console.error(err))\n\n\treturn navigator.clipboard.write([new ClipboardItem(types)]).catch((err) => {\n\t\t// Firefox will fail with the above if `dom.events.asyncClipboard.clipboardItem` is enabled.\n\t\t// See <https://github.com/tldraw/tldraw/issues/1325>\n\t\tconsole.error(err)\n\n\t\treturn Promise.all(\n\t\t\tentries.map(async ([type, promise]) => {\n\t\t\t\treturn [type, await promise] as const\n\t\t\t})\n\t\t).then((entries) => {\n\t\t\tconst resolvedTypes = objectMapFromEntries(entries)\n\t\t\treturn navigator.clipboard.write([new ClipboardItem(resolvedTypes)])\n\t\t})\n\t})\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBAAqD;AAU9C,MAAM,8BAA8B;AAE3C,MAAM,gCAAgC;AAAA,EACrC,aAAa;AACd;AACA,MAAM,8BAA8B;AAAA,EACnC,CAAC,2BAA2B,GAAG;AAChC;AAEO,SAAS,gCAAgC,UAAiC;AAChF,aAAO,8BAAe,+BAA+B,QAAQ,KAAK;AACnE;AACO,SAAS,8BAA8B,UAA0B;AACvE,aAAO,8BAAe,6BAA6B,QAAQ,KAAK;AACjE;AAEO,SAAS,yBAAyB,UAA2B;AACnE,SACC,OAAO,kBAAkB,eACzB,cAAc,iBACb,cAAc,SAAuC,QAAQ;AAEhE;AAEO,SAAS,eAAe,OAAqD;AAMnF,QAAM,UAAU,OAAO,QAAQ,KAAK;AAIpC,aAAW,CAAC,GAAG,OAAO,KAAK,QAAS,SAAQ,MAAM,CAAC,QAAQ,QAAQ,MAAM,GAAG,CAAC;AAE7E,SAAO,UAAU,UAAU,MAAM,CAAC,IAAI,cAAc,KAAK,CAAC,CAAC,EAAE,MAAM,CAAC,QAAQ;AAG3E,YAAQ,MAAM,GAAG;AAEjB,WAAO,QAAQ;AAAA,MACd,QAAQ,IAAI,OAAO,CAAC,MAAM,OAAO,MAAM;AACtC,eAAO,CAAC,MAAM,MAAM,OAAO;AAAA,MAC5B,CAAC;AAAA,IACF,EAAE,KAAK,CAACA,aAAY;AACnB,YAAM,oBAAgB,oCAAqBA,QAAO;AAClD,aAAO,UAAU,UAAU,MAAM,CAAC,IAAI,cAAc,aAAa,CAAC,CAAC;AAAA,IACpE,CAAC;AAAA,EACF,CAAC;AACF;",
  "names": ["entries"]
}
