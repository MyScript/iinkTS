{
  "version": 3,
  "sources": ["../../../../../src/lib/shapes/shared/freehand/getStrokePoints.ts"],
  "sourcesContent": ["import { Vec, VecLike } from '@tldraw/editor'\nimport type { StrokeOptions, StrokePoint } from './types'\n\nconst MIN_START_PRESSURE = 0.025\nconst MIN_END_PRESSURE = 0.01\n\n/**\n * ## getStrokePoints\n *\n * Get an array of points as objects with an adjusted point, pressure, vector, distance, and\n * runningLength.\n *\n * @param points - An array of points (as `[x, y, pressure]` or `{x, y, pressure}`). Pressure is\n *   optional in both cases.\n * @param options - An object with options.\n * @public\n */\nexport function getStrokePoints(\n\trawInputPoints: VecLike[],\n\toptions: StrokeOptions = {}\n): StrokePoint[] {\n\tconst { streamline = 0.5, size = 16, simulatePressure = false } = options\n\n\t// If we don't have any points, return an empty array.\n\tif (rawInputPoints.length === 0) return []\n\n\t// Find the interpolation level between points.\n\tconst t = 0.15 + (1 - streamline) * 0.85\n\n\t// Whatever the input is, make sure that the points are in number[][].\n\tlet pts = rawInputPoints.map(Vec.From)\n\n\tlet pointsRemovedFromNearEnd = 0\n\n\tif (!simulatePressure) {\n\t\t// Strip low pressure points from the start of the array.\n\t\tlet pt = pts[0]\n\t\twhile (pt) {\n\t\t\tif (pt.z >= MIN_START_PRESSURE) break\n\t\t\tpts.shift()\n\t\t\tpt = pts[0]\n\t\t}\n\t}\n\n\tif (!simulatePressure) {\n\t\t// Strip low pressure points from the end of the array.\n\t\tlet pt = pts[pts.length - 1]\n\t\twhile (pt) {\n\t\t\tif (pt.z >= MIN_END_PRESSURE) break\n\t\t\tpts.pop()\n\t\t\tpt = pts[pts.length - 1]\n\t\t}\n\t}\n\n\tif (pts.length === 0)\n\t\treturn [\n\t\t\t{\n\t\t\t\tpoint: Vec.From(rawInputPoints[0]),\n\t\t\t\tinput: Vec.From(rawInputPoints[0]),\n\t\t\t\tpressure: simulatePressure ? 0.5 : 0.15,\n\t\t\t\tvector: new Vec(1, 1),\n\t\t\t\tdistance: 0,\n\t\t\t\trunningLength: 0,\n\t\t\t\tradius: 1,\n\t\t\t},\n\t\t]\n\n\t// Strip points that are too close to the first point.\n\tlet pt = pts[1]\n\twhile (pt) {\n\t\tif (Vec.Dist2(pt, pts[0]) > (size / 3) ** 2) break\n\t\tpts[0].z = Math.max(pts[0].z, pt.z) // Use maximum pressure\n\t\tpts.splice(1, 1)\n\t\tpt = pts[1]\n\t}\n\n\t// Strip points that are too close to the last point.\n\tconst last = pts.pop()!\n\tpt = pts[pts.length - 1]\n\twhile (pt) {\n\t\tif (Vec.Dist2(pt, last) > (size / 3) ** 2) break\n\t\tpts.pop()\n\t\tpt = pts[pts.length - 1]\n\t\tpointsRemovedFromNearEnd++\n\t}\n\tpts.push(last)\n\n\tconst isComplete =\n\t\toptions.last ||\n\t\t!options.simulatePressure ||\n\t\t(pts.length > 1 && Vec.Dist2(pts[pts.length - 1], pts[pts.length - 2]) < size ** 2) ||\n\t\tpointsRemovedFromNearEnd > 0\n\n\t// Add extra points between the two, to help avoid \"dash\" lines\n\t// for strokes with tapered start and ends. Don't mutate the\n\t// input array!\n\tif (pts.length === 2 && options.simulatePressure) {\n\t\tconst last = pts[1]\n\t\tpts = pts.slice(0, -1)\n\t\tfor (let i = 1; i < 5; i++) {\n\t\t\tconst next = Vec.Lrp(pts[0], last, i / 4)\n\t\t\tnext.z = ((pts[0].z + (last.z - pts[0].z)) * i) / 4\n\t\t\tpts.push(next)\n\t\t}\n\t}\n\n\t// The strokePoints array will hold the points for the stroke.\n\t// Start it out with the first point, which needs no adjustment.\n\tconst strokePoints: StrokePoint[] = [\n\t\t{\n\t\t\tpoint: pts[0],\n\t\t\tinput: pts[0],\n\t\t\tpressure: simulatePressure ? 0.5 : pts[0].z,\n\t\t\tvector: new Vec(1, 1),\n\t\t\tdistance: 0,\n\t\t\trunningLength: 0,\n\t\t\tradius: 1,\n\t\t},\n\t]\n\n\t// We use the totalLength to keep track of the total distance\n\tlet totalLength = 0\n\n\t// We're set this to the latest point, so we can use it to calculate\n\t// the distance and vector of the next point.\n\tlet prev = strokePoints[0]\n\n\t// Iterate through all of the points, creating StrokePoints.\n\tlet point: Vec, distance: number\n\n\tif (isComplete && streamline > 0) {\n\t\tpts.push(pts[pts.length - 1].clone())\n\t}\n\n\tfor (let i = 1, n = pts.length; i < n; i++) {\n\t\tpoint =\n\t\t\t!t || (options.last && i === n - 1) ? pts[i].clone() : pts[i].clone().lrp(prev.point, 1 - t)\n\n\t\t// If the new point is the same as the previous point, skip ahead.\n\t\tif (prev.point.equals(point)) continue\n\n\t\t// How far is the new point from the previous point?\n\t\tdistance = Vec.Dist(point, prev.point)\n\n\t\t// Add this distance to the total \"running length\" of the line.\n\t\ttotalLength += distance\n\n\t\t// At the start of the line, we wait until the new point is a\n\t\t// certain distance away from the original point, to avoid noise\n\n\t\tif (i < 4 && totalLength < size) {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Create a new strokepoint (it will be the new \"previous\" one).\n\t\tprev = {\n\t\t\tinput: pts[i],\n\t\t\t// The adjusted point\n\t\t\tpoint,\n\t\t\t// The input pressure (or .5 if not specified)\n\t\t\tpressure: simulatePressure ? 0.5 : pts[i].z,\n\t\t\t// The vector from the current point to the previous point\n\t\t\tvector: Vec.Sub(prev.point, point).uni(),\n\t\t\t// The distance between the current point and the previous point\n\t\t\tdistance,\n\t\t\t// The total distance so far\n\t\t\trunningLength: totalLength,\n\t\t\t// The stroke point's radius\n\t\t\tradius: 1,\n\t\t}\n\n\t\t// Push it to the strokePoints array.\n\t\tstrokePoints.push(prev)\n\t}\n\n\t// Set the vector of the first point to be the same as the second point.\n\tif (strokePoints[1]?.vector) {\n\t\tstrokePoints[0].vector = strokePoints[1].vector.clone()\n\t}\n\n\tif (totalLength < 1) {\n\t\tconst maxPressureAmongPoints = Math.max(0.5, ...strokePoints.map((s) => s.pressure))\n\t\tstrokePoints.forEach((s) => (s.pressure = maxPressureAmongPoints))\n\t}\n\n\treturn strokePoints\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBAA6B;AAG7B,MAAM,qBAAqB;AAC3B,MAAM,mBAAmB;AAalB,SAAS,gBACf,gBACA,UAAyB,CAAC,GACV;AAChB,QAAM,EAAE,aAAa,KAAK,OAAO,IAAI,mBAAmB,MAAM,IAAI;AAGlE,MAAI,eAAe,WAAW,EAAG,QAAO,CAAC;AAGzC,QAAM,IAAI,QAAQ,IAAI,cAAc;AAGpC,MAAI,MAAM,eAAe,IAAI,kBAAI,IAAI;AAErC,MAAI,2BAA2B;AAE/B,MAAI,CAAC,kBAAkB;AAEtB,QAAIA,MAAK,IAAI,CAAC;AACd,WAAOA,KAAI;AACV,UAAIA,IAAG,KAAK,mBAAoB;AAChC,UAAI,MAAM;AACV,MAAAA,MAAK,IAAI,CAAC;AAAA,IACX;AAAA,EACD;AAEA,MAAI,CAAC,kBAAkB;AAEtB,QAAIA,MAAK,IAAI,IAAI,SAAS,CAAC;AAC3B,WAAOA,KAAI;AACV,UAAIA,IAAG,KAAK,iBAAkB;AAC9B,UAAI,IAAI;AACR,MAAAA,MAAK,IAAI,IAAI,SAAS,CAAC;AAAA,IACxB;AAAA,EACD;AAEA,MAAI,IAAI,WAAW;AAClB,WAAO;AAAA,MACN;AAAA,QACC,OAAO,kBAAI,KAAK,eAAe,CAAC,CAAC;AAAA,QACjC,OAAO,kBAAI,KAAK,eAAe,CAAC,CAAC;AAAA,QACjC,UAAU,mBAAmB,MAAM;AAAA,QACnC,QAAQ,IAAI,kBAAI,GAAG,CAAC;AAAA,QACpB,UAAU;AAAA,QACV,eAAe;AAAA,QACf,QAAQ;AAAA,MACT;AAAA,IACD;AAGD,MAAI,KAAK,IAAI,CAAC;AACd,SAAO,IAAI;AACV,QAAI,kBAAI,MAAM,IAAI,IAAI,CAAC,CAAC,KAAK,OAAO,MAAM,EAAG;AAC7C,QAAI,CAAC,EAAE,IAAI,KAAK,IAAI,IAAI,CAAC,EAAE,GAAG,GAAG,CAAC;AAClC,QAAI,OAAO,GAAG,CAAC;AACf,SAAK,IAAI,CAAC;AAAA,EACX;AAGA,QAAM,OAAO,IAAI,IAAI;AACrB,OAAK,IAAI,IAAI,SAAS,CAAC;AACvB,SAAO,IAAI;AACV,QAAI,kBAAI,MAAM,IAAI,IAAI,KAAK,OAAO,MAAM,EAAG;AAC3C,QAAI,IAAI;AACR,SAAK,IAAI,IAAI,SAAS,CAAC;AACvB;AAAA,EACD;AACA,MAAI,KAAK,IAAI;AAEb,QAAM,aACL,QAAQ,QACR,CAAC,QAAQ,oBACR,IAAI,SAAS,KAAK,kBAAI,MAAM,IAAI,IAAI,SAAS,CAAC,GAAG,IAAI,IAAI,SAAS,CAAC,CAAC,IAAI,QAAQ,KACjF,2BAA2B;AAK5B,MAAI,IAAI,WAAW,KAAK,QAAQ,kBAAkB;AACjD,UAAMC,QAAO,IAAI,CAAC;AAClB,UAAM,IAAI,MAAM,GAAG,EAAE;AACrB,aAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC3B,YAAM,OAAO,kBAAI,IAAI,IAAI,CAAC,GAAGA,OAAM,IAAI,CAAC;AACxC,WAAK,KAAM,IAAI,CAAC,EAAE,KAAKA,MAAK,IAAI,IAAI,CAAC,EAAE,MAAM,IAAK;AAClD,UAAI,KAAK,IAAI;AAAA,IACd;AAAA,EACD;AAIA,QAAM,eAA8B;AAAA,IACnC;AAAA,MACC,OAAO,IAAI,CAAC;AAAA,MACZ,OAAO,IAAI,CAAC;AAAA,MACZ,UAAU,mBAAmB,MAAM,IAAI,CAAC,EAAE;AAAA,MAC1C,QAAQ,IAAI,kBAAI,GAAG,CAAC;AAAA,MACpB,UAAU;AAAA,MACV,eAAe;AAAA,MACf,QAAQ;AAAA,IACT;AAAA,EACD;AAGA,MAAI,cAAc;AAIlB,MAAI,OAAO,aAAa,CAAC;AAGzB,MAAI,OAAY;AAEhB,MAAI,cAAc,aAAa,GAAG;AACjC,QAAI,KAAK,IAAI,IAAI,SAAS,CAAC,EAAE,MAAM,CAAC;AAAA,EACrC;AAEA,WAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,IAAI,GAAG,KAAK;AAC3C,YACC,CAAC,KAAM,QAAQ,QAAQ,MAAM,IAAI,IAAK,IAAI,CAAC,EAAE,MAAM,IAAI,IAAI,CAAC,EAAE,MAAM,EAAE,IAAI,KAAK,OAAO,IAAI,CAAC;AAG5F,QAAI,KAAK,MAAM,OAAO,KAAK,EAAG;AAG9B,eAAW,kBAAI,KAAK,OAAO,KAAK,KAAK;AAGrC,mBAAe;AAKf,QAAI,IAAI,KAAK,cAAc,MAAM;AAChC;AAAA,IACD;AAGA,WAAO;AAAA,MACN,OAAO,IAAI,CAAC;AAAA;AAAA,MAEZ;AAAA;AAAA,MAEA,UAAU,mBAAmB,MAAM,IAAI,CAAC,EAAE;AAAA;AAAA,MAE1C,QAAQ,kBAAI,IAAI,KAAK,OAAO,KAAK,EAAE,IAAI;AAAA;AAAA,MAEvC;AAAA;AAAA,MAEA,eAAe;AAAA;AAAA,MAEf,QAAQ;AAAA,IACT;AAGA,iBAAa,KAAK,IAAI;AAAA,EACvB;AAGA,MAAI,aAAa,CAAC,GAAG,QAAQ;AAC5B,iBAAa,CAAC,EAAE,SAAS,aAAa,CAAC,EAAE,OAAO,MAAM;AAAA,EACvD;AAEA,MAAI,cAAc,GAAG;AACpB,UAAM,yBAAyB,KAAK,IAAI,KAAK,GAAG,aAAa,IAAI,CAAC,MAAM,EAAE,QAAQ,CAAC;AACnF,iBAAa,QAAQ,CAAC,MAAO,EAAE,WAAW,sBAAuB;AAAA,EAClE;AAEA,SAAO;AACR;",
  "names": ["pt", "last"]
}
