{
  "version": 3,
  "sources": ["../../../../src/lib/shapes/line/LineShapeUtil.tsx"],
  "sourcesContent": ["import {\n\tCubicSpline2d,\n\tGroup2d,\n\tHandleSnapGeometry,\n\tPolyline2d,\n\tSVGContainer,\n\tShapeUtil,\n\tTLHandle,\n\tTLHandleDragInfo,\n\tTLLineShape,\n\tTLLineShapePoint,\n\tTLResizeInfo,\n\tVec,\n\tWeakCache,\n\tZERO_INDEX_KEY,\n\tgetIndexAbove,\n\tgetIndexBetween,\n\tgetIndices,\n\tgetPerfectDashProps,\n\tlerp,\n\tlineShapeMigrations,\n\tlineShapeProps,\n\tmapObjectMapValues,\n\tmaybeSnapToGrid,\n\tsortByIndex,\n} from '@tldraw/editor'\n\nimport { STROKE_SIZES } from '../arrow/shared'\nimport { useDefaultColorTheme } from '../shared/useDefaultColorTheme'\nimport { getLineDrawPath, getLineIndicatorPath } from './components/getLinePath'\nimport { getDrawLinePathData } from './line-helpers'\n\nconst handlesCache = new WeakCache<TLLineShape['props'], TLHandle[]>()\n\n/** @public */\nexport class LineShapeUtil extends ShapeUtil<TLLineShape> {\n\tstatic override type = 'line' as const\n\tstatic override props = lineShapeProps\n\tstatic override migrations = lineShapeMigrations\n\n\toverride hideResizeHandles() {\n\t\treturn true\n\t}\n\toverride hideRotateHandle() {\n\t\treturn true\n\t}\n\toverride hideSelectionBoundsFg() {\n\t\treturn true\n\t}\n\toverride hideSelectionBoundsBg() {\n\t\treturn true\n\t}\n\n\toverride getDefaultProps(): TLLineShape['props'] {\n\t\tconst [start, end] = getIndices(2)\n\t\treturn {\n\t\t\tdash: 'draw',\n\t\t\tsize: 'm',\n\t\t\tcolor: 'black',\n\t\t\tspline: 'line',\n\t\t\tpoints: {\n\t\t\t\t[start]: { id: start, index: start, x: 0, y: 0 },\n\t\t\t\t[end]: { id: end, index: end, x: 0.1, y: 0.1 },\n\t\t\t},\n\t\t\tscale: 1,\n\t\t}\n\t}\n\n\tgetGeometry(shape: TLLineShape) {\n\t\t// todo: should we have min size?\n\t\treturn getGeometryForLineShape(shape)\n\t}\n\n\toverride getHandles(shape: TLLineShape) {\n\t\treturn handlesCache.get(shape.props, () => {\n\t\t\tconst spline = getGeometryForLineShape(shape)\n\n\t\t\tconst points = linePointsToArray(shape)\n\t\t\tconst results: TLHandle[] = points.map((point) => ({\n\t\t\t\t...point,\n\t\t\t\tid: point.index,\n\t\t\t\ttype: 'vertex',\n\t\t\t\tcanSnap: true,\n\t\t\t}))\n\n\t\t\tfor (let i = 0; i < points.length - 1; i++) {\n\t\t\t\tconst index = getIndexBetween(points[i].index, points[i + 1].index)\n\t\t\t\tconst segment = spline.segments[i]\n\t\t\t\tconst point = segment.midPoint()\n\t\t\t\tresults.push({\n\t\t\t\t\tid: index,\n\t\t\t\t\ttype: 'create',\n\t\t\t\t\tindex,\n\t\t\t\t\tx: point.x,\n\t\t\t\t\ty: point.y,\n\t\t\t\t\tcanSnap: true,\n\t\t\t\t})\n\t\t\t}\n\n\t\t\treturn results.sort(sortByIndex)\n\t\t})\n\t}\n\n\t//   Events\n\n\toverride onResize(shape: TLLineShape, info: TLResizeInfo<TLLineShape>) {\n\t\tconst { scaleX, scaleY } = info\n\n\t\treturn {\n\t\t\tprops: {\n\t\t\t\tpoints: mapObjectMapValues(shape.props.points, (_, { id, index, x, y }) => ({\n\t\t\t\t\tid,\n\t\t\t\t\tindex,\n\t\t\t\t\tx: x * scaleX,\n\t\t\t\t\ty: y * scaleY,\n\t\t\t\t})),\n\t\t\t},\n\t\t}\n\t}\n\n\toverride onBeforeCreate(next: TLLineShape): void | TLLineShape {\n\t\tconst {\n\t\t\tprops: { points },\n\t\t} = next\n\t\tconst pointKeys = Object.keys(points)\n\n\t\tif (pointKeys.length < 2) {\n\t\t\treturn\n\t\t}\n\n\t\tconst firstPoint = points[pointKeys[0]]\n\t\tconst allSame = pointKeys.every((key) => {\n\t\t\tconst point = points[key]\n\t\t\treturn point.x === firstPoint.x && point.y === firstPoint.y\n\t\t})\n\t\tif (allSame) {\n\t\t\tconst lastKey = pointKeys[pointKeys.length - 1]\n\t\t\tpoints[lastKey] = {\n\t\t\t\t...points[lastKey],\n\t\t\t\tx: points[lastKey].x + 0.1,\n\t\t\t\ty: points[lastKey].y + 0.1,\n\t\t\t}\n\t\t\treturn next\n\t\t}\n\t\treturn\n\t}\n\n\toverride onHandleDrag(shape: TLLineShape, { handle }: TLHandleDragInfo<TLLineShape>) {\n\t\t// we should only ever be dragging vertex handles\n\t\tif (handle.type !== 'vertex') return\n\t\tconst newPoint = maybeSnapToGrid(new Vec(handle.x, handle.y), this.editor)\n\t\treturn {\n\t\t\t...shape,\n\t\t\tprops: {\n\t\t\t\t...shape.props,\n\t\t\t\tpoints: {\n\t\t\t\t\t...shape.props.points,\n\t\t\t\t\t[handle.id]: { id: handle.id, index: handle.index, x: newPoint.x, y: newPoint.y },\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t}\n\n\tcomponent(shape: TLLineShape) {\n\t\treturn (\n\t\t\t<SVGContainer>\n\t\t\t\t<LineShapeSvg shape={shape} />\n\t\t\t</SVGContainer>\n\t\t)\n\t}\n\n\tindicator(shape: TLLineShape) {\n\t\tconst strokeWidth = STROKE_SIZES[shape.props.size] * shape.props.scale\n\t\tconst spline = getGeometryForLineShape(shape)\n\t\tconst { dash } = shape.props\n\n\t\tlet path: string\n\n\t\tif (shape.props.spline === 'line') {\n\t\t\tconst outline = spline.points\n\t\t\tif (dash === 'solid' || dash === 'dotted' || dash === 'dashed') {\n\t\t\t\tpath = 'M' + outline[0] + 'L' + outline.slice(1)\n\t\t\t} else {\n\t\t\t\tconst [innerPathData] = getDrawLinePathData(shape.id, outline, strokeWidth)\n\t\t\t\tpath = innerPathData\n\t\t\t}\n\t\t} else {\n\t\t\tpath = getLineIndicatorPath(shape, spline, strokeWidth)\n\t\t}\n\n\t\treturn <path d={path} />\n\t}\n\n\toverride toSvg(shape: TLLineShape) {\n\t\treturn <LineShapeSvg shouldScale shape={shape} />\n\t}\n\n\toverride getHandleSnapGeometry(shape: TLLineShape): HandleSnapGeometry {\n\t\tconst points = linePointsToArray(shape)\n\t\treturn {\n\t\t\tpoints,\n\t\t\tgetSelfSnapPoints: (handle) => {\n\t\t\t\tconst index = this.getHandles(shape)\n\t\t\t\t\t.filter((h) => h.type === 'vertex')\n\t\t\t\t\t.findIndex((h) => h.id === handle.id)!\n\n\t\t\t\t// We want to skip the current and adjacent handles\n\t\t\t\treturn points.filter((_, i) => Math.abs(i - index) > 1).map(Vec.From)\n\t\t\t},\n\t\t\tgetSelfSnapOutline: (handle) => {\n\t\t\t\t// We want to skip the segments that include the handle, so\n\t\t\t\t// find the index of the handle that shares the same index property\n\t\t\t\t// as the initial dragging handle; this catches a quirk of create handles\n\t\t\t\tconst index = this.getHandles(shape)\n\t\t\t\t\t.filter((h) => h.type === 'vertex')\n\t\t\t\t\t.findIndex((h) => h.id === handle.id)!\n\n\t\t\t\t// Get all the outline segments from the shape that don't include the handle\n\t\t\t\tconst segments = getGeometryForLineShape(shape).segments.filter(\n\t\t\t\t\t(_, i) => i !== index - 1 && i !== index\n\t\t\t\t)\n\n\t\t\t\tif (!segments.length) return null\n\t\t\t\treturn new Group2d({ children: segments })\n\t\t\t},\n\t\t}\n\t}\n\toverride getInterpolatedProps(\n\t\tstartShape: TLLineShape,\n\t\tendShape: TLLineShape,\n\t\tt: number\n\t): TLLineShape['props'] {\n\t\tconst startPoints = linePointsToArray(startShape)\n\t\tconst endPoints = linePointsToArray(endShape)\n\n\t\tconst pointsToUseStart: TLLineShapePoint[] = []\n\t\tconst pointsToUseEnd: TLLineShapePoint[] = []\n\n\t\tlet index = ZERO_INDEX_KEY\n\n\t\tif (startPoints.length > endPoints.length) {\n\t\t\t// we'll need to expand points\n\t\t\tfor (let i = 0; i < startPoints.length; i++) {\n\t\t\t\tpointsToUseStart[i] = { ...startPoints[i] }\n\t\t\t\tif (endPoints[i] === undefined) {\n\t\t\t\t\tpointsToUseEnd[i] = { ...endPoints[endPoints.length - 1], id: index }\n\t\t\t\t} else {\n\t\t\t\t\tpointsToUseEnd[i] = { ...endPoints[i], id: index }\n\t\t\t\t}\n\t\t\t\tindex = getIndexAbove(index)\n\t\t\t}\n\t\t} else if (endPoints.length > startPoints.length) {\n\t\t\t// we'll need to converge points\n\t\t\tfor (let i = 0; i < endPoints.length; i++) {\n\t\t\t\tpointsToUseEnd[i] = { ...endPoints[i] }\n\t\t\t\tif (startPoints[i] === undefined) {\n\t\t\t\t\tpointsToUseStart[i] = {\n\t\t\t\t\t\t...startPoints[startPoints.length - 1],\n\t\t\t\t\t\tid: index,\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpointsToUseStart[i] = { ...startPoints[i], id: index }\n\t\t\t\t}\n\t\t\t\tindex = getIndexAbove(index)\n\t\t\t}\n\t\t} else {\n\t\t\t// noop, easy\n\t\t\tfor (let i = 0; i < endPoints.length; i++) {\n\t\t\t\tpointsToUseStart[i] = startPoints[i]\n\t\t\t\tpointsToUseEnd[i] = endPoints[i]\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\t...(t > 0.5 ? endShape.props : startShape.props),\n\t\t\tpoints: Object.fromEntries(\n\t\t\t\tpointsToUseStart.map((point, i) => {\n\t\t\t\t\tconst endPoint = pointsToUseEnd[i]\n\t\t\t\t\treturn [\n\t\t\t\t\t\tpoint.id,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t...point,\n\t\t\t\t\t\t\tx: lerp(point.x, endPoint.x, t),\n\t\t\t\t\t\t\ty: lerp(point.y, endPoint.y, t),\n\t\t\t\t\t\t},\n\t\t\t\t\t]\n\t\t\t\t})\n\t\t\t),\n\t\t\tscale: lerp(startShape.props.scale, endShape.props.scale, t),\n\t\t}\n\t}\n}\n\nfunction linePointsToArray(shape: TLLineShape) {\n\treturn Object.values(shape.props.points).sort(sortByIndex)\n}\n\n/** @public */\nexport function getGeometryForLineShape(shape: TLLineShape): CubicSpline2d | Polyline2d {\n\tconst points = linePointsToArray(shape).map(Vec.From)\n\n\tswitch (shape.props.spline) {\n\t\tcase 'cubic': {\n\t\t\treturn new CubicSpline2d({ points })\n\t\t}\n\t\tcase 'line': {\n\t\t\treturn new Polyline2d({ points })\n\t\t}\n\t}\n}\n\nfunction LineShapeSvg({\n\tshape,\n\tshouldScale = false,\n\tforceSolid = false,\n}: {\n\tshape: TLLineShape\n\tshouldScale?: boolean\n\tforceSolid?: boolean\n}) {\n\tconst theme = useDefaultColorTheme()\n\n\tconst spline = getGeometryForLineShape(shape)\n\tconst { dash, color, size } = shape.props\n\n\tconst scaleFactor = 1 / shape.props.scale\n\n\tconst scale = shouldScale ? scaleFactor : 1\n\n\tconst strokeWidth = STROKE_SIZES[size] * shape.props.scale\n\n\t// Line style lines\n\tif (shape.props.spline === 'line') {\n\t\tif (dash === 'solid') {\n\t\t\tconst outline = spline.points\n\t\t\tconst pathData = 'M' + outline[0] + 'L' + outline.slice(1)\n\n\t\t\treturn (\n\t\t\t\t<path\n\t\t\t\t\td={pathData}\n\t\t\t\t\tstroke={theme[color].solid}\n\t\t\t\t\tstrokeWidth={strokeWidth}\n\t\t\t\t\tfill=\"none\"\n\t\t\t\t\ttransform={`scale(${scale})`}\n\t\t\t\t/>\n\t\t\t)\n\t\t}\n\n\t\tif (dash === 'dashed' || dash === 'dotted') {\n\t\t\treturn (\n\t\t\t\t<g stroke={theme[color].solid} strokeWidth={strokeWidth} transform={`scale(${scale})`}>\n\t\t\t\t\t{spline.segments.map((segment, i) => {\n\t\t\t\t\t\tconst { strokeDasharray, strokeDashoffset } = forceSolid\n\t\t\t\t\t\t\t? { strokeDasharray: 'none', strokeDashoffset: 'none' }\n\t\t\t\t\t\t\t: getPerfectDashProps(segment.length, strokeWidth, {\n\t\t\t\t\t\t\t\t\tstyle: dash,\n\t\t\t\t\t\t\t\t\tstart: i > 0 ? 'outset' : 'none',\n\t\t\t\t\t\t\t\t\tend: i < spline.segments.length - 1 ? 'outset' : 'none',\n\t\t\t\t\t\t\t\t})\n\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t<path\n\t\t\t\t\t\t\t\tkey={i}\n\t\t\t\t\t\t\t\tstrokeDasharray={strokeDasharray}\n\t\t\t\t\t\t\t\tstrokeDashoffset={strokeDashoffset}\n\t\t\t\t\t\t\t\td={segment.getSvgPathData(true)}\n\t\t\t\t\t\t\t\tfill=\"none\"\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t)\n\t\t\t\t\t})}\n\t\t\t\t</g>\n\t\t\t)\n\t\t}\n\n\t\tif (dash === 'draw') {\n\t\t\tconst outline = spline.points\n\t\t\tconst [_, outerPathData] = getDrawLinePathData(shape.id, outline, strokeWidth)\n\n\t\t\treturn (\n\t\t\t\t<path\n\t\t\t\t\td={outerPathData}\n\t\t\t\t\tstroke={theme[color].solid}\n\t\t\t\t\tstrokeWidth={strokeWidth}\n\t\t\t\t\tfill=\"none\"\n\t\t\t\t\ttransform={`scale(${scale})`}\n\t\t\t\t/>\n\t\t\t)\n\t\t}\n\t}\n\t// Cubic style spline\n\tif (shape.props.spline === 'cubic') {\n\t\tconst splinePath = spline.getSvgPathData()\n\t\tif (dash === 'solid') {\n\t\t\treturn (\n\t\t\t\t<path\n\t\t\t\t\tstrokeWidth={strokeWidth}\n\t\t\t\t\tstroke={theme[color].solid}\n\t\t\t\t\tfill=\"none\"\n\t\t\t\t\td={splinePath}\n\t\t\t\t\ttransform={`scale(${scale})`}\n\t\t\t\t/>\n\t\t\t)\n\t\t}\n\n\t\tif (dash === 'dashed' || dash === 'dotted') {\n\t\t\treturn (\n\t\t\t\t<g stroke={theme[color].solid} strokeWidth={strokeWidth} transform={`scale(${scale})`}>\n\t\t\t\t\t{spline.segments.map((segment, i) => {\n\t\t\t\t\t\tconst { strokeDasharray, strokeDashoffset } = getPerfectDashProps(\n\t\t\t\t\t\t\tsegment.length,\n\t\t\t\t\t\t\tstrokeWidth,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstyle: dash,\n\t\t\t\t\t\t\t\tstart: i > 0 ? 'outset' : 'none',\n\t\t\t\t\t\t\t\tend: i < spline.segments.length - 1 ? 'outset' : 'none',\n\t\t\t\t\t\t\t\tforceSolid,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)\n\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t<path\n\t\t\t\t\t\t\t\tkey={i}\n\t\t\t\t\t\t\t\tstrokeDasharray={strokeDasharray}\n\t\t\t\t\t\t\t\tstrokeDashoffset={strokeDashoffset}\n\t\t\t\t\t\t\t\td={segment.getSvgPathData()}\n\t\t\t\t\t\t\t\tfill=\"none\"\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t)\n\t\t\t\t\t})}\n\t\t\t\t</g>\n\t\t\t)\n\t\t}\n\n\t\tif (dash === 'draw') {\n\t\t\treturn (\n\t\t\t\t<path\n\t\t\t\t\td={getLineDrawPath(shape, spline, strokeWidth)}\n\t\t\t\t\tstrokeWidth={1}\n\t\t\t\t\tstroke={theme[color].solid}\n\t\t\t\t\tfill={theme[color].solid}\n\t\t\t\t\ttransform={`scale(${scale})`}\n\t\t\t\t/>\n\t\t\t)\n\t\t}\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
