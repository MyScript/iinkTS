{
  "version": 3,
  "sources": ["../../../../src/lib/shapes/note/noteHelpers.ts"],
  "sourcesContent": ["import { Editor, IndexKey, TLNoteShape, TLShape, Vec, compact, createShapeId } from '@tldraw/editor'\n\n/** @internal */\nexport const CLONE_HANDLE_MARGIN = 0\n/** @internal */\nexport const NOTE_SIZE = 200\n/** @internal */\nexport const NOTE_CENTER_OFFSET = new Vec(NOTE_SIZE / 2, NOTE_SIZE / 2)\n/** @internal */\nexport const NOTE_ADJACENT_POSITION_SNAP_RADIUS = 10\n\nconst BASE_NOTE_POSITIONS = (editor: Editor) =>\n\t[\n\t\t[\n\t\t\t['a1' as IndexKey],\n\t\t\tnew Vec(NOTE_SIZE * 0.5, NOTE_SIZE * -0.5 - editor.options.adjacentShapeMargin),\n\t\t], // t\n\t\t[\n\t\t\t['a2' as IndexKey],\n\t\t\tnew Vec(NOTE_SIZE * 1.5 + editor.options.adjacentShapeMargin, NOTE_SIZE * 0.5),\n\t\t], // r\n\t\t[\n\t\t\t['a3' as IndexKey],\n\t\t\tnew Vec(NOTE_SIZE * 0.5, NOTE_SIZE * 1.5 + editor.options.adjacentShapeMargin),\n\t\t], // b\n\t\t[\n\t\t\t['a4' as IndexKey],\n\t\t\tnew Vec(NOTE_SIZE * -0.5 - editor.options.adjacentShapeMargin, NOTE_SIZE * 0.5),\n\t\t], // l\n\t] as const\n\nfunction getBaseAdjacentNotePositions(editor: Editor, scale: number) {\n\tif (scale === 1) return BASE_NOTE_POSITIONS(editor)\n\tconst s = NOTE_SIZE * scale\n\tconst m = editor.options.adjacentShapeMargin * scale\n\treturn [\n\t\t[['a1' as IndexKey], new Vec(s * 0.5, s * -0.5 - m)], // t\n\t\t[['a2' as IndexKey], new Vec(s * 1.5 + m, s * 0.5)], // r\n\t\t[['a3' as IndexKey], new Vec(s * 0.5, s * 1.5 + m)], // b\n\t\t[['a4' as IndexKey], new Vec(s * -0.5 - m, s * 0.5)], // l\n\t] as const\n}\n\n/**\n * Get the adjacent positions for a particular note shape.\n *\n * @param pagePoint - The point of the note shape on the page.\n * @param pageRotation - The rotation of the note shape on the page.\n * @param growY - The growY of the note shape.\n * @param extraHeight - The extra height to add to the top position above the note shape (ie the growY of the dragging shape).\n *\n * @internal */\nexport function getNoteAdjacentPositions(\n\teditor: Editor,\n\tpagePoint: Vec,\n\tpageRotation: number,\n\tgrowY: number,\n\textraHeight: number,\n\tscale: number\n): Record<IndexKey, Vec> {\n\treturn Object.fromEntries(\n\t\tgetBaseAdjacentNotePositions(editor, scale).map(([id, v], i) => {\n\t\t\tconst point = v.clone()\n\t\t\tif (i === 0 && extraHeight) {\n\t\t\t\t// apply top margin (the growY of the moving note shape)\n\t\t\t\tpoint.y -= extraHeight\n\t\t\t} else if (i === 2 && growY) {\n\t\t\t\t// apply bottom margin (the growY of this note shape)\n\t\t\t\tpoint.y += growY\n\t\t\t}\n\t\t\treturn [id, point.rot(pageRotation).add(pagePoint)]\n\t\t})\n\t)\n}\n\n/**\n * Get all of the available note adjacent positions, excluding the selected shapes.\n *\n * @param editor - The editor instance.\n * @param rotation - The rotation of the note shape.\n * @param extraHeight - The extra height to add to the top position above the note shape (ie the growY of the dragging shape).\n *\n * @internal */\nexport function getAvailableNoteAdjacentPositions(\n\teditor: Editor,\n\trotation: number,\n\tscale: number,\n\textraHeight: number\n) {\n\tconst selectedShapeIds = new Set(editor.getSelectedShapeIds())\n\tconst minSize = (NOTE_SIZE + editor.options.adjacentShapeMargin + extraHeight) ** 2\n\tconst allCenters = new Map<TLNoteShape, Vec>()\n\tconst positions: (Vec | undefined)[] = []\n\n\t// Get all the positions that are adjacent to the selected note shapes\n\tfor (const shape of editor.getCurrentPageShapes()) {\n\t\tif (\n\t\t\t!editor.isShapeOfType<TLNoteShape>(shape, 'note') ||\n\t\t\tscale !== shape.props.scale ||\n\t\t\tselectedShapeIds.has(shape.id)\n\t\t) {\n\t\t\tcontinue\n\t\t}\n\n\t\tconst transform = editor.getShapePageTransform(shape.id)!\n\n\t\t// If the note has a different rotation, we can't use its adjacent positions\n\t\tif (rotation !== transform.rotation()) continue\n\n\t\t// Save the unselected note shape's center\n\t\tallCenters.set(shape, editor.getShapePageBounds(shape)!.center)\n\n\t\t// And push its position to the positions array\n\t\tpositions.push(\n\t\t\t...Object.values(\n\t\t\t\tgetNoteAdjacentPositions(\n\t\t\t\t\teditor,\n\t\t\t\t\ttransform.point(),\n\t\t\t\t\trotation,\n\t\t\t\t\tshape.props.growY,\n\t\t\t\t\textraHeight,\n\t\t\t\t\tscale\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t}\n\n\t// Remove positions that are inside of another note shape\n\tconst len = positions.length\n\tlet position: Vec | undefined\n\tfor (const [shape, center] of allCenters) {\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tposition = positions[i]\n\t\t\tif (!position) continue\n\t\t\tif (Vec.Dist2(center, position) > minSize) continue\n\t\t\tif (editor.isPointInShape(shape, position)) {\n\t\t\t\tpositions[i] = undefined\n\t\t\t}\n\t\t}\n\t}\n\n\treturn compact(positions)\n}\n\n/**\n * For a particular adjacent note position, get the shape in that position or create a new one.\n *\n * @param editor - The editor instance.\n * @param shape - The note shape to create or select.\n * @param center - The center of the note shape.\n * @param pageRotation - The rotation of the note shape on the page.\n * @param forceNew - Whether to force the creation of a new note shape.\n *\n * @internal */\nexport function getNoteShapeForAdjacentPosition(\n\teditor: Editor,\n\tshape: TLNoteShape,\n\tcenter: Vec,\n\tpageRotation: number,\n\tforceNew = false\n) {\n\t// There might already be a note in that position! If there is, we'll\n\t// select the next note and switch focus to it. If there's not, then\n\t// we'll create a new note in that position.\n\n\tlet nextNote: TLShape | undefined\n\n\t// Check the center of where a new note would be\n\t// Start from the top of the stack, and work our way down\n\tconst allShapesOnPage = editor.getCurrentPageShapesSorted()\n\n\tconst minDistance = (NOTE_SIZE + editor.options.adjacentShapeMargin ** 2) ** shape.props.scale\n\n\tfor (let i = allShapesOnPage.length - 1; i >= 0; i--) {\n\t\tconst otherNote = allShapesOnPage[i]\n\t\tif (otherNote.type === 'note' && otherNote.id !== shape.id) {\n\t\t\tconst otherBounds = editor.getShapePageBounds(otherNote)\n\t\t\tif (\n\t\t\t\totherBounds &&\n\t\t\t\tVec.Dist2(otherBounds.center, center) < minDistance &&\n\t\t\t\teditor.isPointInShape(otherNote, center)\n\t\t\t) {\n\t\t\t\tnextNote = otherNote\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\teditor.complete()\n\n\t// If we didn't find any in that position, then create a new one\n\tif (!nextNote || forceNew) {\n\t\teditor.markHistoryStoppingPoint('creating note shape')\n\t\tconst id = createShapeId()\n\n\t\t// We create it at the center first, so that it becomes\n\t\t// the child of whatever parent was at that center\n\t\teditor.createShape({\n\t\t\tid,\n\t\t\ttype: 'note',\n\t\t\tx: center.x,\n\t\t\ty: center.y,\n\t\t\trotation: pageRotation,\n\t\t\topacity: shape.opacity,\n\t\t\tprops: {\n\t\t\t\t// Use the props of the shape we're cloning\n\t\t\t\t...shape.props,\n\t\t\t\t// ...except for these values, which should reset to their defaults\n\t\t\t\ttext: '',\n\t\t\t\tgrowY: 0,\n\t\t\t\tfontSizeAdjustment: 0,\n\t\t\t\turl: '',\n\t\t\t},\n\t\t})\n\n\t\t// Now we need to correct its location within its new parent\n\n\t\tconst createdShape = editor.getShape<TLNoteShape>(id)!\n\t\tif (!createdShape) return // may have hit max shapes\n\n\t\t// We need to put the page point in the same coordinate space as the newly created shape (i.e its parent's space)\n\t\tconst topLeft = editor.getPointInParentSpace(\n\t\t\tcreatedShape,\n\t\t\tVec.Sub(\n\t\t\t\tcenter,\n\t\t\t\tVec.Rot(NOTE_CENTER_OFFSET.clone().mul(createdShape.props.scale), pageRotation)\n\t\t\t)\n\t\t)\n\n\t\teditor.updateShape({\n\t\t\tid,\n\t\t\ttype: 'note',\n\t\t\tx: topLeft.x,\n\t\t\ty: topLeft.y,\n\t\t})\n\n\t\tnextNote = editor.getShape(id)!\n\t}\n\n\tzoomToShapeIfOffscreen(editor)\n\treturn nextNote\n}\n\nconst ZOOM_TO_SHAPE_PADDING = 16\nfunction zoomToShapeIfOffscreen(editor: Editor) {\n\tconst selectionPageBounds = editor.getSelectionPageBounds()\n\tconst viewportPageBounds = editor.getViewportPageBounds()\n\tif (selectionPageBounds && !viewportPageBounds.contains(selectionPageBounds)) {\n\t\tconst eb = selectionPageBounds\n\t\t\t.clone()\n\t\t\t// Expand the bounds by the padding\n\t\t\t.expandBy(ZOOM_TO_SHAPE_PADDING / editor.getZoomLevel())\n\t\t\t// then expand the bounds to include the viewport bounds\n\t\t\t.expand(viewportPageBounds)\n\n\t\t// then use the difference between the centers to calculate the offset\n\t\tconst nextBounds = viewportPageBounds.clone().translate({\n\t\t\tx: (eb.center.x - viewportPageBounds.center.x) * 2,\n\t\t\ty: (eb.center.y - viewportPageBounds.center.y) * 2,\n\t\t})\n\t\teditor.zoomToBounds(nextBounds, {\n\t\t\tanimation: {\n\t\t\t\tduration: editor.options.animationMediumMs,\n\t\t\t},\n\t\t\tinset: 0,\n\t\t})\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
