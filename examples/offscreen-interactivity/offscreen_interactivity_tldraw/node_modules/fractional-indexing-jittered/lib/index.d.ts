interface IndexCharacterSetOptions {
    chars: string;
    jitterRange?: number;
    firstPositive?: string;
    mostPositive?: string;
    mostNegative?: string;
}
interface IndexedCharacterSet {
    chars: string;
    byChar: Record<string, number>;
    byCode: Record<number, string>;
    paddingDict: Record<number, number>;
    length: number;
    first: string;
    last: string;
    firstPositive: string;
    mostPositive: string;
    firstNegative: string;
    mostNegative: string;
    jitterRange: number;
}
declare function indexCharacterSet(options: IndexCharacterSetOptions): IndexedCharacterSet;
declare function base62CharSet(): IndexedCharacterSet;

/**
 * Generate a key between two other keys.
 * If either lower or upper is null, the key will be generated at the start or end of the list.
 */
declare function generateKeyBetween(lower: string | null, upper: string | null, charSet?: IndexedCharacterSet): string;
/**
 * Generate any number of keys between two other keys.
 * If either lower or upper is null, the keys will be generated at the start or end of the list.
 */
declare function generateNKeysBetween(a: string | null, b: string | null, n: number, charSet?: IndexedCharacterSet): string[];
/**
 * Generate a key between two other keys with jitter.
 * If either lower or upper is null, the key will be generated at the start or end of the list.
 */
declare function generateJitteredKeyBetween(lower: string | null, upper: string | null, charSet?: IndexedCharacterSet): string;
/**
 * Generate any number of keys between two other keys with jitter.
 * If either lower or upper is null, the keys will be generated at the start or end of the list.
 */
declare function generateNJitteredKeysBetween(lower: string | null, upper: string | null, n: number, charSet?: IndexedCharacterSet): string[];

interface GeneratorOptions {
    charSet?: IndexedCharacterSet;
    useJitter?: boolean;
    groupIdLength?: number;
}
declare class IndexGenerator {
    private charSet;
    private useJitter;
    private list;
    private useGroups;
    private groupIdLength;
    constructor(list: string[], options?: GeneratorOptions);
    /**
     * Updates the list that the generator uses to generate keys.
     * The generator will not mutate the internal list when generating keys.
     */
    updateList(list: string[]): void;
    /**
     * Generate any number of keys at the start of the list (before the first key).
     * Optionally you can supply a groupId to generate keys at the start of a specific group.
     */
    nKeysStart(n: number, groupId?: string): string[];
    /**
     * Generate a single key at the start of the list (before the first key).
     * Optionally you can supply a groupId to generate a key at the start of a specific group.
     */
    keyStart(groupId?: string): string;
    /**
     * Generate any number of keys at the end of the list (after the last key).
     * Optionally you can supply a groupId to generate keys at the end of a specific group.
     */
    nKeysEnd(n: number, groupId?: string): string[];
    /**
     * Generate a single key at the end of the list (after the last key).
     * Optionally you can supply a groupId to generate a key at the end of a specific group.
     */
    keyEnd(groupId?: string): string;
    /**
     * Generate any number of keys behind a specific key and in front of the next key.
     * GroupId will be inferred from the orderKey if working with groups
     */
    nKeysAfter(orderKey: string, n: number): string[];
    /**
     * Generate a single key behind a specific key and in front of the next key.
     * GroupId will be inferred from the orderKey if working with groups
     */
    keyAfter(orderKey: string): string;
    /**
     * Generate any number of keys in front of a specific key and behind the previous key.
     * GroupId will be inferred from the orderKey if working with groups
     */
    nKeysBefore(orderKey: string, n: number): string[];
    /**
     * Generate a single key in front of a specific key and behind the previous key.
     * GroupId will be inferred from the orderKey if working with groups
     */
    keyBefore(orderKey: string): string;
    /**
     * private function responsible for calling the correct generate function
     */
    private generateNKeysBetween;
    /**
     * get the key before the supplied orderKey, if it exists and is in the same group
     */
    private getKeyBefore;
    /**
     * get the key after the supplied orderKey, if it exists and is in the same group
     */
    private getKeyAfter;
    /**
     * get the first key of the group (or the first key of the list if not using groups)
     */
    private firstOfGroup;
    /**
     * get the last key of the group (or the last key of the list if not using groups)
     */
    private lastOfGroup;
    /**
     * throw an error if the groupId is invalid or supplied when not using groups
     */
    private validateGroupId;
    /**
     * get the groupId from the orderKey
     */
    private groupId;
    /**
     * remove the groupId from the orderKey
     */
    private groupLessKey;
    /**
     * split the orderKey into groupId and key
     * if not using groups, orderKey will be the same as key
     */
    private splitIntoGroupIdAndOrderKey;
    /**
     * check if two keys are in the same group
     * if not using groups, keys will always be in the same group
     */
    private isSameGroup;
    /**
     * check if the key is part of the group
     * if not using groups, key will always be part of the group
     */
    private isPartOfGroup;
}

export { type GeneratorOptions, IndexGenerator, base62CharSet, generateJitteredKeyBetween, generateKeyBetween, generateNJitteredKeysBetween, generateNKeysBetween, indexCharacterSet };
