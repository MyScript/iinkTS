"use strict";var me=Object.defineProperty;var ut=Object.getOwnPropertyDescriptor;var yt=Object.getOwnPropertyNames;var dt=Object.prototype.hasOwnProperty;var pt=(e,t)=>{for(var c in t)me(e,c,{get:t[c],enumerable:!0})},ct=(e,t,c,Q)=>{if(t&&typeof t=="object"||typeof t=="function")for(let p of yt(t))!dt.call(e,p)&&p!==c&&me(e,p,{get:()=>t[p],enumerable:!(Q=ut(t,p))||Q.enumerable});return e};var lt=e=>ct(me({},"__esModule",{value:!0}),e);var Dt={};pt(Dt,{QueryStatus:()=>se,_NEVER:()=>We,buildCreateApi:()=>le,copyWithStructuralSharing:()=>Z,coreModule:()=>fe,coreModuleName:()=>ae,createApi:()=>st,defaultSerializeQueryArgs:()=>oe,fakeBaseQuery:()=>$e,fetchBaseQuery:()=>ke,retry:()=>Pe,setupListeners:()=>ve,skipToken:()=>ie});module.exports=lt(Dt);var se=(p=>(p.uninitialized="uninitialized",p.pending="pending",p.fulfilled="fulfilled",p.rejected="rejected",p))(se||{});function Qe(e){return{status:e,isUninitialized:e==="uninitialized",isLoading:e==="pending",isSuccess:e==="fulfilled",isError:e==="rejected"}}var r=require("@reduxjs/toolkit");var Re=r.isPlainObject;function Z(e,t){if(e===t||!(Re(e)&&Re(t)||Array.isArray(e)&&Array.isArray(t)))return t;let c=Object.keys(t),Q=Object.keys(e),p=c.length===Q.length,S=Array.isArray(t)?[]:{};for(let D of c)S[D]=Z(e[D],t[D]),p&&(p=e[D]===S[D]);return p?e:S}function U(e){let t=0;for(let c in e)t++;return t}var ge=e=>[].concat(...e);function xe(e){return new RegExp("(^|:)//").test(e)}function Se(){return typeof document>"u"?!0:document.visibilityState!=="hidden"}function W(e){return e!=null}function Ae(){return typeof navigator>"u"||navigator.onLine===void 0?!0:navigator.onLine}var ft=e=>e.replace(/\/$/,""),mt=e=>e.replace(/^\//,"");function De(e,t){if(!e)return t;if(!t)return e;if(xe(t))return t;let c=e.endsWith("/")||!t.startsWith("?")?"/":"";return e=ft(e),t=mt(t),`${e}${c}${t}`}function be(e,t,c){return e.has(t)?e.get(t):e.set(t,c).get(t)}var Ee=(...e)=>fetch(...e),gt=e=>e.status>=200&&e.status<=299,Tt=e=>/ion\/(vnd\.api\+)?json/.test(e.get("content-type")||"");function Me(e){if(!(0,r.isPlainObject)(e))return e;let t={...e};for(let[c,Q]of Object.entries(t))Q===void 0&&delete t[c];return t}function ke({baseUrl:e,prepareHeaders:t=f=>f,fetchFn:c=Ee,paramsSerializer:Q,isJsonContentType:p=Tt,jsonContentType:S="application/json",jsonReplacer:D,timeout:k,responseHandler:B,validateStatus:x,...b}={}){return typeof fetch>"u"&&c===Ee&&console.warn("Warning: `fetch` is not available. Please supply a custom `fetchFn` property to use `fetchBaseQuery` on SSR environments."),async(a,i,T)=>{let{getState:s,extra:l,endpoint:d,forced:n,type:g}=i,R,{url:A,headers:h=new Headers(b.headers),params:o=void 0,responseHandler:m=B??"json",validateStatus:u=x??gt,timeout:y=k,...M}=typeof a=="string"?{url:a}:a,E,P=i.signal;y&&(E=new AbortController,i.signal.addEventListener("abort",E.abort),P=E.signal);let v={...b,signal:P,...M};h=new Headers(Me(h)),v.headers=await t(h,{getState:s,arg:a,extra:l,endpoint:d,forced:n,type:g,extraOptions:T})||h;let C=I=>typeof I=="object"&&((0,r.isPlainObject)(I)||Array.isArray(I)||typeof I.toJSON=="function");if(!v.headers.has("content-type")&&C(v.body)&&v.headers.set("content-type",S),C(v.body)&&p(v.headers)&&(v.body=JSON.stringify(v.body,D)),o){let I=~A.indexOf("?")?"&":"?",z=Q?Q(o):new URLSearchParams(Me(o));A+=I+z}A=De(e,A);let F=new Request(A,v);R={request:new Request(A,v)};let w,q=!1,N=E&&setTimeout(()=>{q=!0,E.abort()},y);try{w=await c(F)}catch(I){return{error:{status:q?"TIMEOUT_ERROR":"FETCH_ERROR",error:String(I)},meta:R}}finally{N&&clearTimeout(N),E?.signal.removeEventListener("abort",E.abort)}let X=w.clone();R.response=X;let K,O="";try{let I;if(await Promise.all([f(w,m).then(z=>K=z,z=>I=z),X.text().then(z=>O=z,()=>{})]),I)throw I}catch(I){return{error:{status:"PARSING_ERROR",originalStatus:w.status,data:O,error:String(I)},meta:R}}return u(w,K)?{data:K,meta:R}:{error:{status:w.status,data:K},meta:R}};async function f(a,i){if(typeof i=="function")return i(a);if(i==="content-type"&&(i=p(a.headers)?"json":"text"),i==="json"){let T=await a.text();return T.length?JSON.parse(T):null}return a.text()}}var j=class{constructor(t,c=void 0){this.value=t;this.meta=c}};async function ht(e=0,t=5){let c=Math.min(e,t),Q=~~((Math.random()+.4)*(300<<c));await new Promise(p=>setTimeout(S=>p(S),Q))}function Qt(e,t){throw Object.assign(new j({error:e,meta:t}),{throwImmediately:!0})}var Be={},Rt=(e,t)=>async(c,Q,p)=>{let S=[5,(t||Be).maxRetries,(p||Be).maxRetries].filter(b=>b!==void 0),[D]=S.slice(-1),B={maxRetries:D,backoff:ht,retryCondition:(b,f,{attempt:a})=>a<=D,...t,...p},x=0;for(;;)try{let b=await e(c,Q,p);if(b.error)throw new j(b);return b}catch(b){if(x++,b.throwImmediately){if(b instanceof j)return b.value;throw b}if(b instanceof j&&!B.retryCondition(b.value.error,c,{attempt:x,baseQueryApi:Q,extraOptions:p}))return b.value;await B.backoff(x,B.maxRetries)}},Pe=Object.assign(Rt,{fail:Qt});var _=(0,r.createAction)("__rtkq/focused"),J=(0,r.createAction)("__rtkq/unfocused"),V=(0,r.createAction)("__rtkq/online"),G=(0,r.createAction)("__rtkq/offline"),Te=!1;function ve(e,t){function c(){let Q=()=>e(_()),p=()=>e(J()),S=()=>e(V()),D=()=>e(G()),k=()=>{window.document.visibilityState==="visible"?Q():p()};return Te||typeof window<"u"&&window.addEventListener&&(window.addEventListener("visibilitychange",k,!1),window.addEventListener("focus",Q,!1),window.addEventListener("online",S,!1),window.addEventListener("offline",D,!1),Te=!0),()=>{window.removeEventListener("focus",Q),window.removeEventListener("visibilitychange",k),window.removeEventListener("online",S),window.removeEventListener("offline",D),Te=!1}}return t?t(e,{onFocus:_,onFocusLost:J,onOffline:G,onOnline:V}):c()}function ye(e){return e.type==="query"}function Ce(e){return e.type==="mutation"}function ee(e,t,c,Q,p,S){return xt(e)?e(t,c,Q,p).filter(W).map(ue).map(S):Array.isArray(e)?e.map(ue).map(S):[]}function xt(e){return typeof e=="function"}function ue(e){return typeof e=="string"?{type:e}:e}var de=require("immer");var Gt=require("@reduxjs/toolkit");function we(e,t){return e.catch(t)}var Y=Symbol("forceQueryFn"),te=e=>typeof e[Y]=="function";function Fe({serializeQueryArgs:e,queryThunk:t,mutationThunk:c,api:Q,context:p}){let S=new Map,D=new Map,{unsubscribeQueryResult:k,removeMutationResult:B,updateSubscriptionOptions:x}=Q.internalActions;return{buildInitiateQuery:s,buildInitiateMutation:l,getRunningQueryThunk:b,getRunningMutationThunk:f,getRunningQueriesThunk:a,getRunningMutationsThunk:i};function b(d,n){return g=>{let R=p.endpointDefinitions[d],A=e({queryArgs:n,endpointDefinition:R,endpointName:d});return S.get(g)?.[A]}}function f(d,n){return g=>D.get(g)?.[n]}function a(){return d=>Object.values(S.get(d)||{}).filter(W)}function i(){return d=>Object.values(D.get(d)||{}).filter(W)}function T(d){}function s(d,n){let g=(R,{subscribe:A=!0,forceRefetch:h,subscriptionOptions:o,[Y]:m,...u}={})=>(y,M)=>{let E=e({queryArgs:R,endpointDefinition:n,endpointName:d}),P=t({...u,type:"query",subscribe:A,forceRefetch:h,subscriptionOptions:o,endpointName:d,originalArgs:R,queryCacheKey:E,[Y]:m}),v=Q.endpoints[d].select(R),C=y(P),F=v(M());let{requestId:H,abort:w}=C,q=F.requestId!==H,N=S.get(y)?.[E],X=()=>v(M()),K=Object.assign(m?C.then(X):q&&!N?Promise.resolve(F):Promise.all([N,C]).then(X),{arg:R,requestId:H,subscriptionOptions:o,queryCacheKey:E,abort:w,async unwrap(){let O=await K;if(O.isError)throw O.error;return O.data},refetch:()=>y(g(R,{subscribe:!1,forceRefetch:!0})),unsubscribe(){A&&y(k({queryCacheKey:E,requestId:H}))},updateSubscriptionOptions(O){K.subscriptionOptions=O,y(x({endpointName:d,requestId:H,queryCacheKey:E,options:O}))}});if(!N&&!q&&!m){let O=be(S,y,{});O[E]=K,K.then(()=>{delete O[E],U(O)||S.delete(y)})}return K};return g}function l(d){return(n,{track:g=!0,fixedCacheKey:R}={})=>(A,h)=>{let o=c({type:"mutation",endpointName:d,originalArgs:n,track:g,fixedCacheKey:R}),m=A(o);let{requestId:u,abort:y,unwrap:M}=m,E=we(m.unwrap().then(F=>({data:F})),F=>({error:F})),P=()=>{A(B({requestId:u,fixedCacheKey:R}))},v=Object.assign(E,{arg:m.arg,requestId:u,abort:y,unwrap:M,reset:P}),C=D.get(A)||{};return D.set(A,C),C[u]=v,v.then(()=>{delete C[u],U(C)||D.delete(A)}),R&&(C[R]=v,v.then(()=>{C[R]===v&&(delete C[R],U(C)||D.delete(A))})),v}}}function Ie(e){return e}function Oe({reducerPath:e,baseQuery:t,context:{endpointDefinitions:c},serializeQueryArgs:Q,api:p,assertTagType:S}){let D=(n,g,R,A)=>(h,o)=>{let m=c[n],u=Q({queryArgs:g,endpointDefinition:m,endpointName:n});if(h(p.internalActions.queryResultPatched({queryCacheKey:u,patches:R})),!A)return;let y=p.endpoints[n].select(g)(o()),M=ee(m.providesTags,y.data,void 0,g,{},S);h(p.internalActions.updateProvidedBy({queryCacheKey:u,providedTags:M}))},k=(n,g,R,A=!0)=>(h,o)=>{let u=p.endpoints[n].select(g)(o()),y={patches:[],inversePatches:[],undo:()=>h(p.util.patchQueryData(n,g,y.inversePatches,A))};if(u.status==="uninitialized")return y;let M;if("data"in u)if((0,de.isDraftable)(u.data)){let[E,P,v]=(0,de.produceWithPatches)(u.data,R);y.patches.push(...P),y.inversePatches.push(...v),M=E}else M=R(u.data),y.patches.push({op:"replace",path:[],value:M}),y.inversePatches.push({op:"replace",path:[],value:u.data});return y.patches.length===0||h(p.util.patchQueryData(n,g,y.patches,A)),y},B=(n,g,R)=>A=>A(p.endpoints[n].initiate(g,{subscribe:!1,forceRefetch:!0,[Y]:()=>({data:R})})),x=async(n,{signal:g,abort:R,rejectWithValue:A,fulfillWithValue:h,dispatch:o,getState:m,extra:u})=>{let y=c[n.endpointName];try{let M=Ie,E,P={signal:g,abort:R,dispatch:o,getState:m,extra:u,endpoint:n.endpointName,type:n.type,forced:n.type==="query"?b(n,m()):void 0,queryCacheKey:n.type==="query"?n.queryCacheKey:void 0},v=n.type==="query"?n[Y]:void 0;if(v?E=v():y.query?(E=await t(y.query(n.originalArgs),P,y.extraOptions),y.transformResponse&&(M=y.transformResponse)):E=await y.queryFn(n.originalArgs,P,y.extraOptions,C=>t(C,P,y.extraOptions)),typeof process<"u",E.error)throw new j(E.error,E.meta);return h(await M(E.data,E.meta,n.originalArgs),{fulfilledTimeStamp:Date.now(),baseQueryMeta:E.meta,[r.SHOULD_AUTOBATCH]:!0})}catch(M){let E=M;if(E instanceof j){let P=Ie;y.query&&y.transformErrorResponse&&(P=y.transformErrorResponse);try{return A(await P(E.value,E.meta,n.originalArgs),{baseQueryMeta:E.meta,[r.SHOULD_AUTOBATCH]:!0})}catch(v){E=v}}throw typeof process<"u",console.error(E),E}};function b(n,g){let R=g[e]?.queries?.[n.queryCacheKey],A=g[e]?.config.refetchOnMountOrArgChange,h=R?.fulfilledTimeStamp,o=n.forceRefetch??(n.subscribe&&A);return o?o===!0||(Number(new Date)-Number(h))/1e3>=o:!1}let f=(0,r.createAsyncThunk)(`${e}/executeQuery`,x,{getPendingMeta(){return{startedTimeStamp:Date.now(),[r.SHOULD_AUTOBATCH]:!0}},condition(n,{getState:g}){let R=g(),A=R[e]?.queries?.[n.queryCacheKey],h=A?.fulfilledTimeStamp,o=n.originalArgs,m=A?.originalArgs,u=c[n.endpointName];return te(n)?!0:A?.status==="pending"?!1:b(n,R)||ye(u)&&u?.forceRefetch?.({currentArg:o,previousArg:m,endpointState:A,state:R})?!0:!h},dispatchConditionRejection:!0}),a=(0,r.createAsyncThunk)(`${e}/executeMutation`,x,{getPendingMeta(){return{startedTimeStamp:Date.now(),[r.SHOULD_AUTOBATCH]:!0}}}),i=n=>"force"in n,T=n=>"ifOlderThan"in n,s=(n,g,R)=>(A,h)=>{let o=i(R)&&R.force,m=T(R)&&R.ifOlderThan,u=(M=!0)=>{let E={forceRefetch:M,isPrefetch:!0};return p.endpoints[n].initiate(g,E)},y=p.endpoints[n].select(g)(h());if(o)A(u());else if(m){let M=y?.fulfilledTimeStamp;if(!M){A(u());return}(Number(new Date)-Number(new Date(M)))/1e3>=m&&A(u())}else A(u(!1))};function l(n){return g=>g?.meta?.arg?.endpointName===n}function d(n,g){return{matchPending:(0,r.isAllOf)((0,r.isPending)(n),l(g)),matchFulfilled:(0,r.isAllOf)((0,r.isFulfilled)(n),l(g)),matchRejected:(0,r.isAllOf)((0,r.isRejected)(n),l(g))}}return{queryThunk:f,mutationThunk:a,prefetch:s,updateQueryData:k,upsertQueryData:B,patchQueryData:D,buildMatchThunkActions:d}}function pe(e,t,c,Q){return ee(c[e.meta.arg.endpointName][t],(0,r.isFulfilled)(e)?e.payload:void 0,(0,r.isRejectedWithValue)(e)?e.payload:void 0,e.meta.arg.originalArgs,"baseQueryMeta"in e.meta?e.meta.baseQueryMeta:void 0,Q)}var Ne=require("immer"),re=require("immer");function ce(e,t,c){let Q=e[t];Q&&c(Q)}function $(e){return("arg"in e?e.arg.fixedCacheKey:e.fixedCacheKey)??e.requestId}function qe(e,t,c){let Q=e[$(t)];Q&&c(Q)}var ne={};function Ke({reducerPath:e,queryThunk:t,mutationThunk:c,serializeQueryArgs:Q,context:{endpointDefinitions:p,apiUid:S,extractRehydrationInfo:D,hasRehydrationInfo:k},assertTagType:B,config:x}){let b=(0,r.createAction)(`${e}/resetApiState`);function f(h,o,m,u){h[o.queryCacheKey]??={status:"uninitialized",endpointName:o.endpointName},ce(h,o.queryCacheKey,y=>{y.status="pending",y.requestId=m&&y.requestId?y.requestId:u.requestId,o.originalArgs!==void 0&&(y.originalArgs=o.originalArgs),y.startedTimeStamp=u.startedTimeStamp})}function a(h,o,m){ce(h,o.arg.queryCacheKey,u=>{if(u.requestId!==o.requestId&&!te(o.arg))return;let{merge:y}=p[o.arg.endpointName];if(u.status="fulfilled",y)if(u.data!==void 0){let{fulfilledTimeStamp:M,arg:E,baseQueryMeta:P,requestId:v}=o,C=(0,r.createNextState)(u.data,F=>y(F,m,{arg:E.originalArgs,baseQueryMeta:P,fulfilledTimeStamp:M,requestId:v}));u.data=C}else u.data=m;else u.data=p[o.arg.endpointName].structuralSharing??!0?Z((0,Ne.isDraft)(u.data)?(0,re.original)(u.data):u.data,m):m;delete u.error,u.fulfilledTimeStamp=o.fulfilledTimeStamp})}let i=(0,r.createSlice)({name:`${e}/queries`,initialState:ne,reducers:{removeQueryResult:{reducer(h,{payload:{queryCacheKey:o}}){delete h[o]},prepare:(0,r.prepareAutoBatched)()},cacheEntriesUpserted:{reducer(h,o){for(let m of o.payload){let{queryDescription:u,value:y}=m;f(h,u,!0,{arg:u,requestId:o.meta.requestId,startedTimeStamp:o.meta.timestamp}),a(h,{arg:u,requestId:o.meta.requestId,fulfilledTimeStamp:o.meta.timestamp,baseQueryMeta:{}},y)}},prepare:h=>({payload:h.map(u=>{let{endpointName:y,arg:M,value:E}=u,P=p[y];return{queryDescription:{type:"query",endpointName:y,originalArgs:u.arg,queryCacheKey:Q({queryArgs:M,endpointDefinition:P,endpointName:y})},value:E}}),meta:{[r.SHOULD_AUTOBATCH]:!0,requestId:(0,r.nanoid)(),timestamp:Date.now()}})},queryResultPatched:{reducer(h,{payload:{queryCacheKey:o,patches:m}}){ce(h,o,u=>{u.data=(0,re.applyPatches)(u.data,m.concat())})},prepare:(0,r.prepareAutoBatched)()}},extraReducers(h){h.addCase(t.pending,(o,{meta:m,meta:{arg:u}})=>{let y=te(u);f(o,u,y,m)}).addCase(t.fulfilled,(o,{meta:m,payload:u})=>{a(o,m,u)}).addCase(t.rejected,(o,{meta:{condition:m,arg:u,requestId:y},error:M,payload:E})=>{ce(o,u.queryCacheKey,P=>{if(!m){if(P.requestId!==y)return;P.status="rejected",P.error=E??M}})}).addMatcher(k,(o,m)=>{let{queries:u}=D(m);for(let[y,M]of Object.entries(u))(M?.status==="fulfilled"||M?.status==="rejected")&&(o[y]=M)})}}),T=(0,r.createSlice)({name:`${e}/mutations`,initialState:ne,reducers:{removeMutationResult:{reducer(h,{payload:o}){let m=$(o);m in h&&delete h[m]},prepare:(0,r.prepareAutoBatched)()}},extraReducers(h){h.addCase(c.pending,(o,{meta:m,meta:{requestId:u,arg:y,startedTimeStamp:M}})=>{y.track&&(o[$(m)]={requestId:u,status:"pending",endpointName:y.endpointName,startedTimeStamp:M})}).addCase(c.fulfilled,(o,{payload:m,meta:u})=>{u.arg.track&&qe(o,u,y=>{y.requestId===u.requestId&&(y.status="fulfilled",y.data=m,y.fulfilledTimeStamp=u.fulfilledTimeStamp)})}).addCase(c.rejected,(o,{payload:m,error:u,meta:y})=>{y.arg.track&&qe(o,y,M=>{M.requestId===y.requestId&&(M.status="rejected",M.error=m??u)})}).addMatcher(k,(o,m)=>{let{mutations:u}=D(m);for(let[y,M]of Object.entries(u))(M?.status==="fulfilled"||M?.status==="rejected")&&y!==M?.requestId&&(o[y]=M)})}}),s=(0,r.createSlice)({name:`${e}/invalidation`,initialState:ne,reducers:{updateProvidedBy:{reducer(h,o){let{queryCacheKey:m,providedTags:u}=o.payload;for(let y of Object.values(h))for(let M of Object.values(y)){let E=M.indexOf(m);E!==-1&&M.splice(E,1)}for(let{type:y,id:M}of u){let E=(h[y]??={})[M||"__internal_without_id"]??=[];E.includes(m)||E.push(m)}},prepare:(0,r.prepareAutoBatched)()}},extraReducers(h){h.addCase(i.actions.removeQueryResult,(o,{payload:{queryCacheKey:m}})=>{for(let u of Object.values(o))for(let y of Object.values(u)){let M=y.indexOf(m);M!==-1&&y.splice(M,1)}}).addMatcher(k,(o,m)=>{let{provided:u}=D(m);for(let[y,M]of Object.entries(u))for(let[E,P]of Object.entries(M)){let v=(o[y]??={})[E||"__internal_without_id"]??=[];for(let C of P)v.includes(C)||v.push(C)}}).addMatcher((0,r.isAnyOf)((0,r.isFulfilled)(t),(0,r.isRejectedWithValue)(t)),(o,m)=>{let u=pe(m,"providesTags",p,B),{queryCacheKey:y}=m.meta.arg;s.caseReducers.updateProvidedBy(o,s.actions.updateProvidedBy({queryCacheKey:y,providedTags:u}))})}}),l=(0,r.createSlice)({name:`${e}/subscriptions`,initialState:ne,reducers:{updateSubscriptionOptions(h,o){},unsubscribeQueryResult(h,o){},internal_getRTKQSubscriptions(){}}}),d=(0,r.createSlice)({name:`${e}/internalSubscriptions`,initialState:ne,reducers:{subscriptionsUpdated:{reducer(h,o){return(0,re.applyPatches)(h,o.payload)},prepare:(0,r.prepareAutoBatched)()}}}),n=(0,r.createSlice)({name:`${e}/config`,initialState:{online:Ae(),focused:Se(),middlewareRegistered:!1,...x},reducers:{middlewareRegistered(h,{payload:o}){h.middlewareRegistered=h.middlewareRegistered==="conflict"||S!==o?"conflict":!0}},extraReducers:h=>{h.addCase(V,o=>{o.online=!0}).addCase(G,o=>{o.online=!1}).addCase(_,o=>{o.focused=!0}).addCase(J,o=>{o.focused=!1}).addMatcher(k,o=>({...o}))}}),g=(0,r.combineReducers)({queries:i.reducer,mutations:T.reducer,provided:s.reducer,subscriptions:d.reducer,config:n.reducer}),R=(h,o)=>g(b.match(o)?void 0:h,o),A={...n.actions,...i.actions,...l.actions,...d.actions,...T.actions,...s.actions,resetApiState:b};return{reducer:R,actions:A}}var ie=Symbol.for("RTKQ/skipToken"),Le={status:"uninitialized"},Ue=(0,r.createNextState)(Le,()=>{}),je=(0,r.createNextState)(Le,()=>{});function He({serializeQueryArgs:e,reducerPath:t,createSelector:c}){let Q=f=>Ue,p=f=>je;return{buildQuerySelector:k,buildMutationSelector:B,selectInvalidatedBy:x,selectCachedArgsForQuery:b};function S(f){return{...f,...Qe(f.status)}}function D(f){return f[t]}function k(f,a){return i=>{if(i===ie)return c(Q,S);let T=e({queryArgs:i,endpointDefinition:a,endpointName:f});return c(l=>D(l)?.queries?.[T]??Ue,S)}}function B(){return f=>{let a;return typeof f=="object"?a=$(f)??ie:a=f,c(a===ie?p:s=>D(s)?.mutations?.[a]??je,S)}}function x(f,a){let i=f[t],T=new Set;for(let s of a.filter(W).map(ue)){let l=i.provided[s.type];if(!l)continue;let d=(s.id!==void 0?l[s.id]:ge(Object.values(l)))??[];for(let n of d)T.add(n)}return ge(Array.from(T.values()).map(s=>{let l=i.queries[s];return l?[{queryCacheKey:s,endpointName:l.endpointName,originalArgs:l.originalArgs}]:[]}))}function b(f,a){return Object.values(f[t].queries).filter(i=>i?.endpointName===a&&i.status!=="uninitialized").map(i=>i.originalArgs)}}var Ve=require("@reduxjs/toolkit");var _e=WeakMap?new WeakMap:void 0,oe=({endpointName:e,queryArgs:t})=>{let c="",Q=_e?.get(t);if(typeof Q=="string")c=Q;else{let p=JSON.stringify(t,(S,D)=>(D=typeof D=="bigint"?{$bigint:D.toString()}:D,D=(0,r.isPlainObject)(D)?Object.keys(D).sort().reduce((k,B)=>(k[B]=D[B],k),{}):D,D));(0,r.isPlainObject)(t)&&_e?.set(t,p),c=p}return`${e}(${c})`};var he=require("reselect");function le(...e){return function(c){let Q=(0,he.weakMapMemoize)(x=>c.extractRehydrationInfo?.(x,{reducerPath:c.reducerPath??"api"})),p={reducerPath:"api",keepUnusedDataFor:60,refetchOnMountOrArgChange:!1,refetchOnFocus:!1,refetchOnReconnect:!1,invalidationBehavior:"delayed",...c,extractRehydrationInfo:Q,serializeQueryArgs(x){let b=oe;if("serializeQueryArgs"in x.endpointDefinition){let f=x.endpointDefinition.serializeQueryArgs;b=a=>{let i=f(a);return typeof i=="string"?i:oe({...a,queryArgs:i})}}else c.serializeQueryArgs&&(b=c.serializeQueryArgs);return b(x)},tagTypes:[...c.tagTypes||[]]},S={endpointDefinitions:{},batch(x){x()},apiUid:(0,r.nanoid)(),extractRehydrationInfo:Q,hasRehydrationInfo:(0,he.weakMapMemoize)(x=>Q(x)!=null)},D={injectEndpoints:B,enhanceEndpoints({addTagTypes:x,endpoints:b}){if(x)for(let f of x)p.tagTypes.includes(f)||p.tagTypes.push(f);if(b)for(let[f,a]of Object.entries(b))typeof a=="function"?a(S.endpointDefinitions[f]):Object.assign(S.endpointDefinitions[f]||{},a);return D}},k=e.map(x=>x.init(D,p,S));function B(x){let b=x.endpoints({query:f=>({...f,type:"query"}),mutation:f=>({...f,type:"mutation"})});for(let[f,a]of Object.entries(b)){if(x.overrideExisting!==!0&&f in S.endpointDefinitions){if(x.overrideExisting==="throw")throw new Error((0,Ve.formatProdErrorMessage)(39));typeof process<"u";continue}S.endpointDefinitions[f]=a;for(let i of k)i.injectEndpoint(f,a)}return D}return D.injectEndpoints({endpoints:c.endpoints})}}var ze=require("@reduxjs/toolkit"),We=Symbol();function $e(){return function(){throw new Error((0,ze.formatProdErrorMessage)(33))}}var at=require("immer");function L(e,...t){return Object.assign(e,...t)}var Je=require("immer");var Ge=({api:e,queryThunk:t,internalState:c})=>{let Q=`${e.reducerPath}/subscriptions`,p=null,S=null,{updateSubscriptionOptions:D,unsubscribeQueryResult:k}=e.internalActions,B=(i,T)=>{if(D.match(T)){let{queryCacheKey:l,requestId:d,options:n}=T.payload;return i?.[l]?.[d]&&(i[l][d]=n),!0}if(k.match(T)){let{queryCacheKey:l,requestId:d}=T.payload;return i[l]&&delete i[l][d],!0}if(e.internalActions.removeQueryResult.match(T))return delete i[T.payload.queryCacheKey],!0;if(t.pending.match(T)){let{meta:{arg:l,requestId:d}}=T,n=i[l.queryCacheKey]??={};return n[`${d}_running`]={},l.subscribe&&(n[d]=l.subscriptionOptions??n[d]??{}),!0}let s=!1;if(t.fulfilled.match(T)||t.rejected.match(T)){let l=i[T.meta.arg.queryCacheKey]||{},d=`${T.meta.requestId}_running`;s||=!!l[d],delete l[d]}if(t.rejected.match(T)){let{meta:{condition:l,arg:d,requestId:n}}=T;if(l&&d.subscribe){let g=i[d.queryCacheKey]??={};g[n]=d.subscriptionOptions??g[n]??{},s=!0}}return s},x=()=>c.currentSubscriptions,a={getSubscriptions:x,getSubscriptionCount:i=>{let s=x()[i]??{};return U(s)},isRequestSubscribed:(i,T)=>!!x()?.[i]?.[T]};return(i,T)=>{if(p||(p=JSON.parse(JSON.stringify(c.currentSubscriptions))),e.util.resetApiState.match(i))return p=c.currentSubscriptions={},S=null,[!0,!1];if(e.internalActions.internal_getRTKQSubscriptions.match(i))return[!1,a];let s=B(c.currentSubscriptions,i),l=!0;if(s){S||(S=setTimeout(()=>{let g=JSON.parse(JSON.stringify(c.currentSubscriptions)),[,R]=(0,Je.produceWithPatches)(p,()=>g);T.next(e.internalActions.subscriptionsUpdated(R)),p=g,S=null},500));let d=typeof i.type=="string"&&!!i.type.startsWith(Q),n=t.rejected.match(i)&&i.meta.condition&&!!i.meta.arg.subscribe;l=!d&&!n}return[l,!1]}};function St(e){for(let t in e)return!1;return!0}var At=2147483647/1e3-1,Ye=({reducerPath:e,api:t,queryThunk:c,context:Q,internalState:p})=>{let{removeQueryResult:S,unsubscribeQueryResult:D,cacheEntriesUpserted:k}=t.internalActions,B=(0,r.isAnyOf)(D.match,c.fulfilled,c.rejected,k.match);function x(i){let T=p.currentSubscriptions[i];return!!T&&!St(T)}let b={},f=(i,T,s)=>{if(B(i)){let l=T.getState()[e],d;if(k.match(i))d=i.payload.map(n=>n.queryDescription.queryCacheKey);else{let{queryCacheKey:n}=D.match(i)?i.payload:i.meta.arg;d=[n]}for(let n of d)a(n,l.queries[n]?.endpointName,T,l.config)}if(t.util.resetApiState.match(i))for(let[l,d]of Object.entries(b))d&&clearTimeout(d),delete b[l];if(Q.hasRehydrationInfo(i)){let l=T.getState()[e],{queries:d}=Q.extractRehydrationInfo(i);for(let[n,g]of Object.entries(d))a(n,g?.endpointName,T,l.config)}};function a(i,T,s,l){let n=Q.endpointDefinitions[T]?.keepUnusedDataFor??l.keepUnusedDataFor;if(n===1/0)return;let g=Math.max(0,Math.min(n,At));if(!x(i)){let R=b[i];R&&clearTimeout(R),b[i]=setTimeout(()=>{x(i)||s.dispatch(S({queryCacheKey:i})),delete b[i]},g*1e3)}}return f};var Xe=new Error("Promise never resolved before cacheEntryRemoved."),Ze=({api:e,reducerPath:t,context:c,queryThunk:Q,mutationThunk:p,internalState:S})=>{let D=(0,r.isAsyncThunkAction)(Q),k=(0,r.isAsyncThunkAction)(p),B=(0,r.isFulfilled)(Q,p),x={};function b(s,l,d){let n=x[s];n?.valueResolved&&(n.valueResolved({data:l,meta:d}),delete n.valueResolved)}function f(s){let l=x[s];l&&(delete x[s],l.cacheEntryRemoved())}let a=(s,l,d)=>{let n=i(s);function g(R,A,h,o){let m=d[t].queries[A],u=l.getState()[t].queries[A];!m&&u&&T(R,o,A,l,h)}if(Q.pending.match(s))g(s.meta.arg.endpointName,n,s.meta.requestId,s.meta.arg.originalArgs);else if(e.internalActions.cacheEntriesUpserted.match(s))for(let{queryDescription:R,value:A}of s.payload){let{endpointName:h,originalArgs:o,queryCacheKey:m}=R;g(h,m,s.meta.requestId,o),b(m,A,{})}else if(p.pending.match(s))l.getState()[t].mutations[n]&&T(s.meta.arg.endpointName,s.meta.arg.originalArgs,n,l,s.meta.requestId);else if(B(s))b(n,s.payload,s.meta.baseQueryMeta);else if(e.internalActions.removeQueryResult.match(s)||e.internalActions.removeMutationResult.match(s))f(n);else if(e.util.resetApiState.match(s))for(let R of Object.keys(x))f(R)};function i(s){return D(s)?s.meta.arg.queryCacheKey:k(s)?s.meta.arg.fixedCacheKey??s.meta.requestId:e.internalActions.removeQueryResult.match(s)?s.payload.queryCacheKey:e.internalActions.removeMutationResult.match(s)?$(s.payload):""}function T(s,l,d,n,g){let R=c.endpointDefinitions[s],A=R?.onCacheEntryAdded;if(!A)return;let h={},o=new Promise(P=>{h.cacheEntryRemoved=P}),m=Promise.race([new Promise(P=>{h.valueResolved=P}),o.then(()=>{throw Xe})]);m.catch(()=>{}),x[d]=h;let u=e.endpoints[s].select(R.type==="query"?l:d),y=n.dispatch((P,v,C)=>C),M={...n,getCacheEntry:()=>u(n.getState()),requestId:g,extra:y,updateCachedData:R.type==="query"?P=>n.dispatch(e.util.updateQueryData(s,l,P)):void 0,cacheDataLoaded:m,cacheEntryRemoved:o},E=A(l,M);Promise.resolve(E).catch(P=>{if(P!==Xe)throw P})}return a};var et=({api:e,context:{apiUid:t},reducerPath:c})=>(Q,p)=>{e.util.resetApiState.match(Q)&&p.dispatch(e.internalActions.middlewareRegistered(t)),typeof process<"u"};var tt=({reducerPath:e,context:t,context:{endpointDefinitions:c},mutationThunk:Q,queryThunk:p,api:S,assertTagType:D,refetchQuery:k,internalState:B})=>{let{removeQueryResult:x}=S.internalActions,b=(0,r.isAnyOf)((0,r.isFulfilled)(Q),(0,r.isRejectedWithValue)(Q)),f=(0,r.isAnyOf)((0,r.isFulfilled)(Q,p),(0,r.isRejected)(Q,p)),a=[],i=(l,d)=>{b(l)?s(pe(l,"invalidatesTags",c,D),d):f(l)?s([],d):S.util.invalidateTags.match(l)&&s(ee(l.payload,void 0,void 0,void 0,void 0,D),d)};function T(l){for(let d in l.queries)if(l.queries[d]?.status==="pending")return!0;for(let d in l.mutations)if(l.mutations[d]?.status==="pending")return!0;return!1}function s(l,d){let n=d.getState(),g=n[e];if(a.push(...l),g.config.invalidationBehavior==="delayed"&&T(g))return;let R=a;if(a=[],R.length===0)return;let A=S.util.selectInvalidatedBy(n,R);t.batch(()=>{let h=Array.from(A.values());for(let{queryCacheKey:o}of h){let m=g.queries[o],u=B.currentSubscriptions[o]??{};m&&(U(u)===0?d.dispatch(x({queryCacheKey:o})):m.status!=="uninitialized"&&d.dispatch(k(m)))}})}return i};var nt=({reducerPath:e,queryThunk:t,api:c,refetchQuery:Q,internalState:p})=>{let S={},D=(a,i)=>{(c.internalActions.updateSubscriptionOptions.match(a)||c.internalActions.unsubscribeQueryResult.match(a))&&B(a.payload,i),(t.pending.match(a)||t.rejected.match(a)&&a.meta.condition)&&B(a.meta.arg,i),(t.fulfilled.match(a)||t.rejected.match(a)&&!a.meta.condition)&&k(a.meta.arg,i),c.util.resetApiState.match(a)&&b()};function k({queryCacheKey:a},i){let T=i.getState()[e],s=T.queries[a],l=p.currentSubscriptions[a];if(!s||s.status==="uninitialized")return;let{lowestPollingInterval:d,skipPollingIfUnfocused:n}=f(l);if(!Number.isFinite(d))return;let g=S[a];g?.timeout&&(clearTimeout(g.timeout),g.timeout=void 0);let R=Date.now()+d;S[a]={nextPollTimestamp:R,pollingInterval:d,timeout:setTimeout(()=>{(T.config.focused||!n)&&i.dispatch(Q(s)),k({queryCacheKey:a},i)},d)}}function B({queryCacheKey:a},i){let s=i.getState()[e].queries[a],l=p.currentSubscriptions[a];if(!s||s.status==="uninitialized")return;let{lowestPollingInterval:d}=f(l);if(!Number.isFinite(d)){x(a);return}let n=S[a],g=Date.now()+d;(!n||g<n.nextPollTimestamp)&&k({queryCacheKey:a},i)}function x(a){let i=S[a];i?.timeout&&clearTimeout(i.timeout),delete S[a]}function b(){for(let a of Object.keys(S))x(a)}function f(a={}){let i=!1,T=Number.POSITIVE_INFINITY;for(let s in a)a[s].pollingInterval&&(T=Math.min(a[s].pollingInterval,T),i=a[s].skipPollingIfUnfocused||i);return{lowestPollingInterval:T,skipPollingIfUnfocused:i}}return D};var rt=({api:e,context:t,queryThunk:c,mutationThunk:Q})=>{let p=(0,r.isPending)(c,Q),S=(0,r.isRejected)(c,Q),D=(0,r.isFulfilled)(c,Q),k={};return(x,b)=>{if(p(x)){let{requestId:f,arg:{endpointName:a,originalArgs:i}}=x.meta,T=t.endpointDefinitions[a],s=T?.onQueryStarted;if(s){let l={},d=new Promise((A,h)=>{l.resolve=A,l.reject=h});d.catch(()=>{}),k[f]=l;let n=e.endpoints[a].select(T.type==="query"?i:f),g=b.dispatch((A,h,o)=>o),R={...b,getCacheEntry:()=>n(b.getState()),requestId:f,extra:g,updateCachedData:T.type==="query"?A=>b.dispatch(e.util.updateQueryData(a,i,A)):void 0,queryFulfilled:d};s(i,R)}}else if(D(x)){let{requestId:f,baseQueryMeta:a}=x.meta;k[f]?.resolve({data:x.payload,meta:a}),delete k[f]}else if(S(x)){let{requestId:f,rejectedWithValue:a,baseQueryMeta:i}=x.meta;k[f]?.reject({error:x.payload??x.error,isUnhandledError:!a,meta:i}),delete k[f]}}};var it=({reducerPath:e,context:t,api:c,refetchQuery:Q,internalState:p})=>{let{removeQueryResult:S}=c.internalActions,D=(B,x)=>{_.match(B)&&k(x,"refetchOnFocus"),V.match(B)&&k(x,"refetchOnReconnect")};function k(B,x){let b=B.getState()[e],f=b.queries,a=p.currentSubscriptions;t.batch(()=>{for(let i of Object.keys(a)){let T=f[i],s=a[i];if(!s||!T)continue;(Object.values(s).some(d=>d[x]===!0)||Object.values(s).every(d=>d[x]===void 0)&&b.config[x])&&(U(s)===0?B.dispatch(S({queryCacheKey:i})):T.status!=="uninitialized"&&B.dispatch(Q(T)))}})}return D};function ot(e){let{reducerPath:t,queryThunk:c,api:Q,context:p}=e,{apiUid:S}=p,D={invalidateTags:(0,r.createAction)(`${t}/invalidateTags`)},k=f=>f.type.startsWith(`${t}/`),B=[et,Ye,tt,nt,Ze,rt];return{middleware:f=>{let a=!1,T={...e,internalState:{currentSubscriptions:{}},refetchQuery:b,isThisApiSliceAction:k},s=B.map(n=>n(T)),l=Ge(T),d=it(T);return n=>g=>{if(!(0,r.isAction)(g))return n(g);a||(a=!0,f.dispatch(Q.internalActions.middlewareRegistered(S)));let R={...f,next:n},A=f.getState(),[h,o]=l(g,R,A),m;if(h?m=n(g):m=o,f.getState()[t]&&(d(g,R,A),k(g)||p.hasRehydrationInfo(g)))for(let u of s)u(g,R,A);return m}},actions:D};function b(f){return e.api.endpoints[f.endpointName].initiate(f.originalArgs,{subscribe:!1,forceRefetch:!0})}}var ae=Symbol(),fe=({createSelector:e=r.createSelector}={})=>({name:ae,init(t,{baseQuery:c,tagTypes:Q,reducerPath:p,serializeQueryArgs:S,keepUnusedDataFor:D,refetchOnMountOrArgChange:k,refetchOnFocus:B,refetchOnReconnect:x,invalidationBehavior:b},f){(0,at.enablePatches)();let a=w=>(typeof process<"u",w);Object.assign(t,{reducerPath:p,endpoints:{},internalActions:{onOnline:V,onOffline:G,onFocus:_,onFocusLost:J},util:{}});let{queryThunk:i,mutationThunk:T,patchQueryData:s,updateQueryData:l,upsertQueryData:d,prefetch:n,buildMatchThunkActions:g}=Oe({baseQuery:c,reducerPath:p,context:f,api:t,serializeQueryArgs:S,assertTagType:a}),{reducer:R,actions:A}=Ke({context:f,queryThunk:i,mutationThunk:T,serializeQueryArgs:S,reducerPath:p,assertTagType:a,config:{refetchOnFocus:B,refetchOnReconnect:x,refetchOnMountOrArgChange:k,keepUnusedDataFor:D,reducerPath:p,invalidationBehavior:b}});L(t.util,{patchQueryData:s,updateQueryData:l,upsertQueryData:d,prefetch:n,resetApiState:A.resetApiState,upsertQueryEntries:A.cacheEntriesUpserted}),L(t.internalActions,A);let{middleware:h,actions:o}=ot({reducerPath:p,context:f,queryThunk:i,mutationThunk:T,api:t,assertTagType:a});L(t.util,o),L(t,{reducer:R,middleware:h});let{buildQuerySelector:m,buildMutationSelector:u,selectInvalidatedBy:y,selectCachedArgsForQuery:M}=He({serializeQueryArgs:S,reducerPath:p,createSelector:e});L(t.util,{selectInvalidatedBy:y,selectCachedArgsForQuery:M});let{buildInitiateQuery:E,buildInitiateMutation:P,getRunningMutationThunk:v,getRunningMutationsThunk:C,getRunningQueriesThunk:F,getRunningQueryThunk:H}=Fe({queryThunk:i,mutationThunk:T,api:t,serializeQueryArgs:S,context:f});return L(t.util,{getRunningMutationThunk:v,getRunningMutationsThunk:C,getRunningQueryThunk:H,getRunningQueriesThunk:F}),{name:ae,injectEndpoint(w,q){let N=t;N.endpoints[w]??={},ye(q)?L(N.endpoints[w],{name:w,select:m(w,q),initiate:E(w,q)},g(i,w)):Ce(q)&&L(N.endpoints[w],{name:w,select:u(),initiate:P(w)},g(T,w))}}}});var st=le(fe());0&&(module.exports={QueryStatus,_NEVER,buildCreateApi,copyWithStructuralSharing,coreModule,coreModuleName,createApi,defaultSerializeQueryArgs,fakeBaseQuery,fetchBaseQuery,retry,setupListeners,skipToken});
//# sourceMappingURL=rtk-query.production.min.cjs.map